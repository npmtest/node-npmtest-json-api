{"/home/travis/build/npmtest/node-npmtest-json-api/test.js":"/* istanbul instrument in package npmtest_json_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-json-api/lib.npmtest_json_api.js":"/* istanbul instrument in package npmtest_json_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_json_api = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_json_api = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-json-api/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-json-api && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_json_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_json_api\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_json_api.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_json_api.rollup.js'] =\n            local.assetsDict['/assets.npmtest_json_api.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_json_api.__dirname + '/lib.npmtest_json_api.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/index.js":"/**\n * Peer dependencies may or may not be installed (npm@3 doesn't install them\n * automatically, and users may not need every peer dependency if they bring\n * their own adapters/strategies). So the code below only tries to require them\n * when they're asked for, as doing otherwise can cause errors.\n */\nmodule.exports = {\n  dbAdapters: {\n    get Mongoose() {\n      return require('./build/src/db-adapters/Mongoose/MongooseAdapter')\n    }\n  },\n  httpStrategies: {\n    get Express() {\n      return require('./build/src/http-strategies/Express')\n    },\n    get Koa() {\n      return require('./build/src/http-strategies/Koa')\n    }\n  },\n  types: {\n    Collection: require('./build/src/types/Collection'),\n    Document: require('./build/src/types/Document'),\n    Error: require('./build/src/types/APIError'),\n    Resource: require('./build/src/types/Resource'),\n    Relationship: require('./build/src/types/Relationship'),\n    Linkage: require('./build/src/types/Linkage'),\n    Documentation: {\n      Field: require('./build/src/types/Documentation/Field'),\n      FieldType: require('./build/src/types/Documentation/FieldType')\n    }\n  },\n  controllers: {\n    API: require('./build/src/controllers/API'),\n    Documentation: require('./build/src/controllers/Documentation')\n  },\n  ResourceTypeRegistry: require('./build/src/ResourceTypeRegistry')\n};\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Collection.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Collection = (function () {\n  function Collection() {\n    var resources = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n    _classCallCheck(this, Collection);\n\n    this.resources = resources;\n  }\n\n  _createClass(Collection, [{\n    key: \"add\",\n    value: function add(resource) {\n      this.resources.push(resource);\n    }\n  }, {\n    key: \"ids\",\n    get: function get() {\n      return this.resources.map(function (it) {\n        return it.id;\n      });\n    }\n  }, {\n    key: \"types\",\n    get: function get() {\n      return this.resources.map(function (it) {\n        return it.type;\n      });\n    }\n  }]);\n\n  return Collection;\n})();\n\nexports[\"default\"] = Collection;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Document.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Linkage = require(\"./Linkage\");\n\nvar _Linkage2 = _interopRequireDefault(_Linkage);\n\nvar _Resource = require(\"./Resource\");\n\nvar _Resource2 = _interopRequireDefault(_Resource);\n\nvar _Collection = require(\"./Collection\");\n\nvar _Collection2 = _interopRequireDefault(_Collection);\n\nvar _utilTypeHandling = require(\"../util/type-handling\");\n\nvar _utilArrays = require(\"../util/arrays\");\n\nvar _urlTemplate = require(\"url-template\");\n\nvar _urlTemplate2 = _interopRequireDefault(_urlTemplate);\n\nvar Document = (function () {\n  function Document(primaryOrErrors, included, meta, urlTemplates, reqURI) {\n    _classCallCheck(this, Document);\n\n    // validate meta\n    var _ref = [primaryOrErrors, included, reqURI];\n    this.primaryOrErrors = _ref[0];\n    this.included = _ref[1];\n    this.reqURI = _ref[2];\n    if (meta !== undefined) {\n      if (typeof meta === \"object\" && !Array.isArray(meta)) {\n        this.meta = meta;\n      } else {\n        throw new Error(\"Meta information must be an object\");\n      }\n    }\n\n    // parse all the templates once on construction.\n    this.urlTemplates = (0, _utilTypeHandling.mapObject)(urlTemplates || {}, function (templatesForType) {\n      return (0, _utilTypeHandling.mapObject)(templatesForType, _urlTemplate2[\"default\"].parse.bind(_urlTemplate2[\"default\"]));\n    });\n\n    this.reqURI = reqURI;\n  }\n\n  _createClass(Document, [{\n    key: \"get\",\n    value: function get(stringify) {\n      var _this = this;\n\n      var doc = {};\n\n      if (this.meta) doc.meta = this.meta;\n\n      // TODO: top-level related link.\n      if (this.reqURI) {\n        doc.links = { \"self\": this.reqURI };\n      }\n\n      if (this.primaryOrErrors instanceof _Collection2[\"default\"] || this.primaryOrErrors instanceof _Resource2[\"default\"]) {\n        doc.data = (0, _utilTypeHandling.mapResources)(this.primaryOrErrors, function (resource) {\n          return resourceToJSON(resource, _this.urlTemplates);\n        });\n      } else if (this.primaryOrErrors instanceof _Linkage2[\"default\"]) {\n        doc.data = linkageToJSON(this.primaryOrErrors);\n      } else if (this.primaryOrErrors === null) {\n        doc.data = this.primaryOrErrors;\n      }\n\n      // it's either resource, a collection, linkage, null, or errors...\n      else {\n          doc.errors = this.primaryOrErrors.map(errorToJSON);\n        }\n\n      if (this.included && this.included instanceof _Collection2[\"default\"]) {\n        doc.included = (0, _utilArrays.arrayUnique)(this.included.resources).map(function (resource) {\n          return resourceToJSON(resource, _this.urlTemplates);\n        });\n      }\n\n      return stringify ? JSON.stringify(doc) : doc;\n    }\n  }]);\n\n  return Document;\n})();\n\nexports[\"default\"] = Document;\n\nfunction linkageToJSON(linkage) {\n  return linkage && linkage.value;\n}\n\nfunction relationshipToJSON(relationship, urlTemplates, templateData) {\n  var result = {};\n\n  if (relationship.linkage) {\n    result.data = linkageToJSON(relationship.linkage);\n  }\n\n  // Add urls that we can.\n  if (urlTemplates[templateData.ownerType]) {\n    var relatedUrlTemplate = relationship.relatedURITemplate ? _urlTemplate2[\"default\"].parse(relationship.relatedURITemplate) : urlTemplates[templateData.ownerType].related;\n\n    var selfUrlTemplate = relationship.selfURITemplate ? _urlTemplate2[\"default\"].parse(relationship.selfURITemplate) : urlTemplates[templateData.ownerType].relationship;\n\n    if (relatedUrlTemplate || selfUrlTemplate) {\n      result.links = {};\n    }\n\n    if (relatedUrlTemplate) {\n      result.links.related = relatedUrlTemplate.expand(templateData);\n    }\n\n    if (selfUrlTemplate) {\n      result.links.self = selfUrlTemplate.expand(templateData);\n    }\n  }\n\n  return result;\n}\n\nfunction resourceToJSON(resource, urlTemplates) {\n  var json = {};\n  json.id = resource.id;\n  json.type = resource.type;\n  json.attributes = resource.attrs;\n\n  if (resource.meta && !(0, _utilTypeHandling.objectIsEmpty)(resource.meta)) {\n    json.meta = resource.meta;\n  }\n\n  // use type, id, meta and attrs for template data, even though building\n  // links from attr values is usually stupid (but there are cases for it).\n  var templateData = _Object$assign({}, json);\n  var selfTemplate = urlTemplates[resource.type] && urlTemplates[resource.type].self;\n\n  if (!(0, _utilTypeHandling.objectIsEmpty)(resource.links) || selfTemplate) {\n    json.links = {};\n    if (selfTemplate) {\n      json.links.self = selfTemplate.expand(templateData);\n    }\n  }\n\n  if (!(0, _utilTypeHandling.objectIsEmpty)(resource.relationships)) {\n    json.relationships = {};\n\n    for (var path in resource.relationships) {\n      var linkTemplateData = { \"ownerType\": json.type, \"ownerId\": json.id, \"path\": path };\n      json.relationships[path] = relationshipToJSON(resource.relationships[path], urlTemplates, linkTemplateData);\n    }\n  }\n\n  return json;\n}\n\nfunction errorToJSON(error) {\n  var res = {};\n  for (var key in error) {\n    if (error.hasOwnProperty(key)) {\n      res[key] = error[key];\n    }\n  }\n  return res;\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Linkage.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Linkage = (function () {\n  /**\n   * Linkage can be either: null, an empty array,\n   * an object of the form {type, id}, or [{type, id}].\n   */\n\n  function Linkage(value) {\n    _classCallCheck(this, Linkage);\n\n    this.set(value);\n  }\n\n  _createClass(Linkage, [{\n    key: \"set\",\n    value: function set(value) {\n      if (value === null) {\n        this.value = value;\n      } else if (!Array.isArray(value)) {\n        if (isValidLinkageObject(value)) {\n          this.value = value;\n        } else {\n          throw new InvalidLinkageError(value);\n        }\n      } else {\n        this.value = [];\n        value.forEach(this.add.bind(this));\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(newValue) {\n      if (Array.isArray(this.value)) {\n        if (isValidLinkageObject(newValue)) {\n          this.value.push(newValue);\n        } else {\n          throw new InvalidLinkageError(newValue);\n        }\n      } else {\n        throw new Error(\"You can only add values to Linkage objects for to-many relationships.\");\n      }\n    }\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      this.value = Array.isArray(this.value) ? [] : null;\n    }\n  }]);\n\n  return Linkage;\n})();\n\nexports[\"default\"] = Linkage;\n\nfunction InvalidLinkageError(value) {\n  return new Error(\"Invalid linkage value: \" + JSON.stringify(value));\n}\n\nfunction isValidLinkageObject(it) {\n  return typeof it.type === \"string\" && typeof it.id === \"string\";\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Resource.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utilMisc = require(\"../util/misc\");\n\nvar Resource = (function () {\n  function Resource(type, id) {\n    var attrs = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n    var relationships = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n    var meta = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];\n\n    _classCallCheck(this, Resource);\n\n    var _ref = [type, id, attrs, relationships, meta];\n    this.type = _ref[0];\n    this.id = _ref[1];\n    this.attrs = _ref[2];\n    this.relationships = _ref[3];\n    this.meta = _ref[4];\n  }\n\n  /**\n   * Checks that a group of fields (i.e. the attributes or the relationships\n   * objects) are provided as objects and that they don't contain `type` and\n   * `id` members. Also checks that attributes and relationships don't contain\n   * the same keys as one another, and it checks that complex attributes don't\n   * contain \"relationships\" or \"links\" members.\n   *\n   * @param {Object} group The an object of fields (attributes or relationships)\n   *    that the user is trying to add to the Resource.\n   * @param {Object} otherFields The other fields that will still exist on the\n   *    Resource. The new fields are checked against these other fields for\n   *    naming conflicts.\n   * @param {Boolean} isAttributes Whether the `group` points to the attributes\n   *    of the resource. Triggers complex attribute validation.\n   * @return {undefined}\n   * @throws {Error} If the field group is invalid given the other fields.\n   */\n\n  _createClass(Resource, [{\n    key: \"equals\",\n    value: function equals(otherResource) {\n      return this.id === otherResource.id && this.type === otherResource.type;\n    }\n  }, {\n    key: \"removeAttr\",\n    value: function removeAttr(attrPath) {\n      if (this._attrs) {\n        (0, _utilMisc.deleteNested)(attrPath, this._attrs);\n      }\n    }\n  }, {\n    key: \"removeRelationship\",\n    value: function removeRelationship(relationshipPath) {\n      if (this._relationships) {\n        (0, _utilMisc.deleteNested)(relationshipPath, this._relationships);\n      }\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(id) {\n      // allow empty id for the case of a new resource POST.\n      this._id = id ? String(id) : undefined;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      if (!type) {\n        throw new Error(\"type is required\");\n      }\n\n      this._type = String(type);\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this._attrs;\n    },\n    set: function set(attrs) {\n      validateFieldGroup(attrs, this._relationships, true);\n      this._attrs = attrs;\n    }\n  }, {\n    key: \"relationships\",\n    get: function get() {\n      return this._relationships;\n    },\n    set: function set(relationships) {\n      validateFieldGroup(relationships, this._attrs);\n      this._relationships = relationships;\n    }\n  }]);\n\n  return Resource;\n})();\n\nexports[\"default\"] = Resource;\nfunction validateFieldGroup(group, otherFields, isAttributes) {\n  if (!(0, _utilMisc.isPlainObject)(group)) {\n    throw new Error(\"Attributes and relationships must be provided as an object.\");\n  }\n\n  if (typeof group.id !== \"undefined\" || typeof group.type !== \"undefined\") {\n    throw new Error(\"`type` and `id` cannot be used as attribute or relationship names.\");\n  }\n\n  for (var field in group) {\n    if (isAttributes) {\n      validateComplexAttribute(group[field]);\n    }\n\n    if (otherFields !== undefined && typeof otherFields[field] !== \"undefined\") {\n      throw new Error(\"A resource can't have an attribute and a relationship with the same name.\");\n    }\n  }\n}\n\nfunction validateComplexAttribute(attrOrAttrPart) {\n  if ((0, _utilMisc.isPlainObject)(attrOrAttrPart)) {\n    if (typeof attrOrAttrPart.relationships !== \"undefined\" || typeof attrOrAttrPart.links !== \"undefined\") {\n      throw new Error('Complex attributes may not have \"relationships\" or \"links\" keys.');\n    }\n    for (var key in attrOrAttrPart) {\n      validateComplexAttribute(attrOrAttrPart[key]);\n    }\n  } else if (Array.isArray(attrOrAttrPart)) {\n    attrOrAttrPart.forEach(validateComplexAttribute);\n  }\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/util/misc.js":"/**\n * Takes an arbitrary path string e.g. \"user.contact.phone\" and locates the\n * corresponding property on an object `obj` and deletes it (ie. does\n * `delete obj.user.contact.phone`). It doesn't use eval, which makes it safer.\n */\n\"use strict\";\n\nvar _Set = require(\"babel-runtime/core-js/set\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deleteNested = deleteNested;\nexports.isSubsetOf = isSubsetOf;\nexports.isPlainObject = isPlainObject;\nexports.pseudoTopSort = pseudoTopSort;\n\nfunction deleteNested(path, object) {\n  try {\n    var pathParts = path.split(\".\");\n    var lastPartIndex = pathParts.length - 1;\n    var lastPart = pathParts[lastPartIndex];\n    var containingParts = pathParts.slice(0, lastPartIndex);\n    var container = containingParts.reduce(function (obj, part) {\n      return obj[part];\n    }, object);\n\n    if (container.hasOwnProperty(lastPart)) {\n      delete container[lastPart];\n      return true;\n    } else {\n      throw new Error(\"The last property in the path didn't exist on the object.\");\n    }\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Returns whether one array's items are a subset of those in the other.\n * Both array's elements are assumed to be unique.\n */\n\nfunction isSubsetOf(setArr, potentialSubsetArr) {\n  var set = new _Set(setArr);\n\n  return potentialSubsetArr.every(function (it) {\n    return set.has(it) === true;\n  });\n}\n\nfunction isPlainObject(obj) {\n  return typeof obj === \"object\" && !(Array.isArray(obj) || obj === null);\n}\n\n/**\n * Perform a pseudo-topological sort on the provided graph. Pseudo because it\n * assumes that each node only has 0 or 1 incoming edges, as is the case with\n * graphs for parent-child inheritance hierarchies (w/o multiple inheritance).\n * Uses https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n *\n * @param  {string[]} nodes A list of nodes, where each node is just a string.\n *\n * @param {string[]} roots The subset of nodes that have no incoming edges.\n *\n * @param  {object} edges The edges, expressed such that each key is a starting\n * node A, and the value is a set of nodes (as an object literal like\n * {nodeName: true}) for each of which there is an edge from A to that node.\n *\n * @return {string[]} The nodes, sorted.\n */\n\nfunction pseudoTopSort(nodes, edges, roots) {\n  // Do some defensive copying, in case the caller didn't.\n  roots = roots.slice();\n  nodes = nodes.slice();\n  edges = _Object$assign({}, edges);\n  for (var key in edges) {\n    edges[key] = _Object$assign({}, edges[key]);\n  }\n\n  // \"L = Empty list that will contain the sorted elements\"\n  var sortResult = [];\n\n  // \"while S is non-empty do\"\n  while (roots.length) {\n    // \"remove a node n from S\"\n    // We shift() instead of pop() to we preserve more of the\n    // original order, in case it was significant to the user.\n    var thisRoot = roots.shift();\n    var thisRootChildren = edges[thisRoot] || {};\n\n    // \"add n to tail of L\"\n    sortResult.push(thisRoot);\n\n    // \"for each node m with an edge e from n to m do\"\n    for (var child in thisRootChildren) {\n      // \"remove edge e from the graph\"\n      delete thisRootChildren[child];\n\n      // SKIP: \"if m has no other incoming edges...\"\n      // we don't need this check because we assumed max 1 incoming edge.\n      // But: \"then insert m into S\".\n      roots.push(child);\n    }\n  }\n\n  return sortResult;\n}","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/util/type-handling.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _Object$seal = require(\"babel-runtime/core-js/object/seal\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueObject = ValueObject;\nexports.objectIsEmpty = objectIsEmpty;\nexports.mapObject = mapObject;\nexports.mapResources = mapResources;\nexports.forEachResources = forEachResources;\nexports.groupResourcesByType = groupResourcesByType;\nexports.forEachArrayOrVal = forEachArrayOrVal;\nexports.Maybe = Maybe;\n\nvar _typesCollection = require(\"../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\n/**\n * Takes in a constructor function that takes no arguments and returns a new one\n * that takes one argument representing initial values. These initial values\n * will be applied to the properties that exist on the object returned by the\n * input constructor function immediately post-creation. Then the object will be\n * sealed so that no properties can be added or deleted--a nice sanity check.\n */\n\nfunction ValueObject(ConstructorFn) {\n  return function (initialValues) {\n    var obj = new ConstructorFn();\n    var hasOwnProp = Object.prototype.hasOwnProperty;\n\n    // Use initial values where possible.\n    if (initialValues) {\n      for (var key in obj) {\n        if (hasOwnProp.call(obj, key) && hasOwnProp.call(initialValues, key)) {\n          obj[key] = initialValues[key];\n        }\n      }\n    }\n\n    // Object.seal prevents any other properties from being added to the object.\n    // Every property an object needs should be set by the original constructor.\n    return _Object$seal(obj);\n  };\n}\n\nfunction objectIsEmpty(obj) {\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  for (var key in obj) {\n    if (hasOwnProperty.call(obj, key)) return false;\n  }\n  return true;\n}\n\nfunction mapObject(obj, mapFn) {\n  var mappedObj = _Object$assign({}, obj);\n\n  for (var key in mappedObj) {\n    mappedObj[key] = mapFn(obj[key]);\n  }\n\n  return mappedObj;\n}\n\n/**\n * If `resourceOrCollection` is a collection, it applies `mapFn` to each of\n * its resources; otherwise, if `resourceOrCollection` is a single resource,\n * it applies `mapFn` just to that resource. This abstracts a common pattern.\n */\n\nfunction mapResources(resourceOrCollection, mapFn) {\n  if (resourceOrCollection instanceof _typesCollection2[\"default\"]) {\n    return resourceOrCollection.resources.map(mapFn);\n  } else {\n    return mapFn(resourceOrCollection);\n  }\n}\n\nfunction forEachResources(resourceOrCollection, eachFn) {\n  /*eslint-disable no-unused-expressions */\n  if (resourceOrCollection instanceof _typesCollection2[\"default\"]) {\n    resourceOrCollection.resources.forEach(eachFn);\n  } else {\n    return eachFn(resourceOrCollection);\n  }\n  /*eslint-enable */\n}\n\nfunction groupResourcesByType(resourceOrCollection) {\n  var resourcesByType = {};\n  if (resourceOrCollection instanceof _typesCollection2[\"default\"]) {\n    resourceOrCollection.resources.forEach(function (it) {\n      resourcesByType[it.type] = resourcesByType[it.type] || [];\n      resourcesByType[it.type].push(it);\n    });\n  } else {\n    resourcesByType[resourceOrCollection.type] = [resourceOrCollection];\n  }\n  return resourcesByType;\n}\n\nfunction forEachArrayOrVal(arrayOrVal, eachFn) {\n  /*eslint-disable no-unused-expressions */\n  Array.isArray(arrayOrVal) ? arrayOrVal.forEach(eachFn) : eachFn(arrayOrVal);\n  /*eslint-enable */\n}\n\n/**\n * The Maybe monad, with a totally-not-monadic unwrap() so we can\n * get out the raw value w/o needing to pass the monad everywhere.\n *\n * We also match js's convention from Promise of not requiring\n * the user's bind() to always return the monad. If a raw value\n * x is returned, it's converted to Maybe(x).\n */\nvar Nothing = {\n  unwrap: function unwrap() {\n    return undefined;\n  },\n\n  bind: function bind() {\n    return this;\n  }\n};\n\nexports.Nothing = Nothing;\n\nvar Just = (function () {\n  function Just(x) {\n    _classCallCheck(this, Just);\n\n    this.val = x;\n  }\n\n  _createClass(Just, [{\n    key: \"unwrap\",\n    value: function unwrap() {\n      return this.val;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(transform) {\n      var transformed = transform(this.val);\n      if (transformed instanceof Just || transformed === Nothing) {\n        return transformed;\n      } else {\n        return Maybe(transformed);\n      }\n    }\n  }]);\n\n  return Just;\n})();\n\nexports.Just = Just;\n\nfunction Maybe(x) {\n  // Sometimes, null is a valid value, so Nothing only covers undefined.\n  if (x !== undefined) {\n    return new Just(x);\n  } else {\n    return Nothing;\n  }\n}","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/util/arrays.js":"\"use strict\";\n\nvar _Number$isNaN = require(\"babel-runtime/core-js/number/is-nan\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayUnique = arrayUnique;\nexports.arrayValuesMatch = arrayValuesMatch;\nexports.arrayContains = arrayContains;\n\nfunction arrayUnique(array) {\n  return array.filter(function (a, b, c) {\n    return c.indexOf(a, b + 1) < 0;\n  });\n}\n\nfunction arrayValuesMatch(array1, array2) {\n  return array1.length === array2.length && array1.sort().join() === array2.sort().join();\n}\n\nfunction arrayContains(arr, value) {\n  if (!_Number$isNaN(value)) {\n    return arr.indexOf(value) !== -1;\n  } else {\n    return arr.some(_Number$isNaN) === true;\n  }\n}","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/APIError.js":"\"use strict\";\n\nvar _get = require(\"babel-runtime/helpers/get\")[\"default\"];\n\nvar _inherits = require(\"babel-runtime/helpers/inherits\")[\"default\"];\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _slicedToArray = require(\"babel-runtime/helpers/sliced-to-array\")[\"default\"];\n\nvar _Array$from3 = require(\"babel-runtime/core-js/array/from\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar nonEnumerable = { writable: true, enumerable: false };\n\nvar APIError = (function (_Error) {\n  _inherits(APIError, _Error);\n\n  /*eslint-disable no-unused-vars */\n\n  function APIError(status, code, title, detail, links, paths) {\n    var _this = this;\n\n    _classCallCheck(this, APIError);\n\n    _get(Object.getPrototypeOf(APIError.prototype), \"constructor\", this).call(this);\n\n    // Hack around lack of proxy support and default non-enumerability\n    // of class accessor properties, while still giving us validation.\n    Object.defineProperty(this, \"_status\", nonEnumerable);\n    Object.defineProperty(this, \"_code\", nonEnumerable);\n    Object.defineProperty(this, \"status\", {\n      enumerable: true,\n      get: function get() {\n        return _this._status;\n      },\n      set: function set(value) {\n        if (typeof value !== \"undefined\" && value !== null) {\n          _this._status = String(value).toString();\n        } else {\n          _this._status = value;\n        }\n      }\n    });\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      get: function get() {\n        return _this._code;\n      },\n      set: function set(value) {\n        if (typeof value !== \"undefined\" && value !== null) {\n          _this._code = String(value).toString();\n        } else {\n          _this._code = value;\n        }\n      }\n    });\n\n    var _Array$from = _Array$from3(arguments);\n\n    var _Array$from2 = _slicedToArray(_Array$from, 6);\n\n    this.status = _Array$from2[0];\n    this.code = _Array$from2[1];\n    this.title = _Array$from2[2];\n    this.detail = _Array$from2[3];\n    this.links = _Array$from2[4];\n    this.paths = _Array$from2[5];\n  }\n\n  /*eslint-enable */\n\n  /**\n   * Creates a JSON-API Compliant Error Object from a JS Error object\n   *\n   */\n\n  _createClass(APIError, null, [{\n    key: \"fromError\",\n    value: function fromError(err) {\n      var fallbackTitle = \"An unknown error occurred while trying to process this request.\";\n      var ErrorConstructor = this || APIError; // in case this isn't bound.\n\n      if (err instanceof APIError) {\n        return err;\n      }\n\n      // If the error is marked as ready for JSON API display, it's secure\n      // to read values off it and show them to the user. (Note: most of\n      // the args below will probably be null/undefined, but that's fine.)\n      else if (err.isJSONAPIDisplayReady) {\n          return new ErrorConstructor(err.status || err.statusCode || 500, err.code, err.title || fallbackTitle, err.details || (err.message ? err.message : undefined), err.links, err.paths);\n        }\n\n        // Otherwise, we just show a generic error message.\n        else {\n            return new ErrorConstructor(500, undefined, fallbackTitle);\n          }\n    }\n  }]);\n\n  return APIError;\n})(Error);\n\nexports[\"default\"] = APIError;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Relationship.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Relationship = (function () {\n  function Relationship(linkage, relatedURITemplate, selfURITemplate) {\n    _classCallCheck(this, Relationship);\n\n    _Object$assign(this, { linkage: linkage, relatedURITemplate: relatedURITemplate, selfURITemplate: selfURITemplate });\n  }\n\n  _createClass(Relationship, [{\n    key: \"empty\",\n    value: function empty() {\n      this.linkage.empty();\n    }\n  }]);\n\n  return Relationship;\n})();\n\nexports[\"default\"] = Relationship;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Documentation/Field.js":"\"use strict\";\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Field = function Field(name, type, validation, friendlyName, defaultVal) {\n  if (validation === undefined) validation = {};\n\n  _classCallCheck(this, Field);\n\n  // call the property kind to\n  // distinguish it from json api type\n  this.kind = type;\n\n  this.name = name;\n  this.validation = validation;\n  this.friendlyName = friendlyName;\n  this[\"default\"] = defaultVal;\n};\n\nexports[\"default\"] = Field;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Documentation/FieldType.js":"/**\n * This class represents the type of a field (i.e. what type of data it holds)\n * within a resource's schema.\n */\n\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar FieldType = (function () {\n  function FieldType(baseType) {\n    var isArray = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n    _classCallCheck(this, FieldType);\n\n    var _ref = [baseType, isArray];\n    this.baseType = _ref[0];\n    this.isArray = _ref[1];\n  }\n\n  _createClass(FieldType, [{\n    key: \"toString\",\n    value: function toString() {\n      return (this.isArray ? \"Array[\" : \"\") + this.baseType + (this.isArray ? \"]\" : \"\");\n    }\n  }]);\n\n  return FieldType;\n})();\n\nexports[\"default\"] = FieldType;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/controllers/API.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _regeneratorRuntime = require(\"babel-runtime/regenerator\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _co = require(\"co\");\n\nvar _co2 = _interopRequireDefault(_co);\n\nvar _typesHTTPResponse = require(\"../types/HTTP/Response\");\n\nvar _typesHTTPResponse2 = _interopRequireDefault(_typesHTTPResponse);\n\nvar _typesDocument = require(\"../types/Document\");\n\nvar _typesDocument2 = _interopRequireDefault(_typesDocument);\n\nvar _typesCollection = require(\"../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nvar _typesAPIError = require(\"../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _stepsHttpValidateRequest = require(\"../steps/http/validate-request\");\n\nvar requestValidators = _interopRequireWildcard(_stepsHttpValidateRequest);\n\nvar _stepsHttpContentNegotiationNegotiateContentType = require(\"../steps/http/content-negotiation/negotiate-content-type\");\n\nvar _stepsHttpContentNegotiationNegotiateContentType2 = _interopRequireDefault(_stepsHttpContentNegotiationNegotiateContentType);\n\nvar _stepsHttpContentNegotiationValidateContentType = require(\"../steps/http/content-negotiation/validate-content-type\");\n\nvar _stepsHttpContentNegotiationValidateContentType2 = _interopRequireDefault(_stepsHttpContentNegotiationValidateContentType);\n\nvar _stepsPreQueryLabelToIds = require(\"../steps/pre-query/label-to-ids\");\n\nvar _stepsPreQueryLabelToIds2 = _interopRequireDefault(_stepsPreQueryLabelToIds);\n\nvar _stepsPreQueryParseRequestPrimary = require(\"../steps/pre-query/parse-request-primary\");\n\nvar _stepsPreQueryParseRequestPrimary2 = _interopRequireDefault(_stepsPreQueryParseRequestPrimary);\n\nvar _stepsPreQueryValidateDocument = require(\"../steps/pre-query/validate-document\");\n\nvar _stepsPreQueryValidateDocument2 = _interopRequireDefault(_stepsPreQueryValidateDocument);\n\nvar _stepsPreQueryValidateResources = require(\"../steps/pre-query/validate-resources\");\n\nvar _stepsPreQueryValidateResources2 = _interopRequireDefault(_stepsPreQueryValidateResources);\n\nvar _stepsApplyTransform = require(\"../steps/apply-transform\");\n\nvar _stepsApplyTransform2 = _interopRequireDefault(_stepsApplyTransform);\n\nvar _stepsDoQueryDoGet = require(\"../steps/do-query/do-get\");\n\nvar _stepsDoQueryDoGet2 = _interopRequireDefault(_stepsDoQueryDoGet);\n\nvar _stepsDoQueryDoPost = require(\"../steps/do-query/do-post\");\n\nvar _stepsDoQueryDoPost2 = _interopRequireDefault(_stepsDoQueryDoPost);\n\nvar _stepsDoQueryDoPatch = require(\"../steps/do-query/do-patch\");\n\nvar _stepsDoQueryDoPatch2 = _interopRequireDefault(_stepsDoQueryDoPatch);\n\nvar _stepsDoQueryDoDelete = require(\"../steps/do-query/do-delete\");\n\nvar _stepsDoQueryDoDelete2 = _interopRequireDefault(_stepsDoQueryDoDelete);\n\nvar supportedExt = [];\n\n// We have to globally patch Promise for co to work, even though global patches\n// are suboptimal. See https://github.com/ethanresnick/json-api/issues/47\n// We use eval so that the runtime transformer doesn't replace our check for an\n// existing Promise with an invocation of the polyfill.\n/*eslint-disable no-eval */\nGLOBAL.Promise = eval(\"typeof Promise !== 'undefined' ? Promise : undefined\") || require(\"babel-runtime/core-js/promise\")[\"default\"];\n/*eslint-enable no-eval */\n\nvar APIController = (function () {\n  function APIController(registry) {\n    _classCallCheck(this, APIController);\n\n    this.registry = registry;\n  }\n\n  /**\n   * @param {Request} request The Request this controller will use to generate\n   *    the Response.\n   * @param {Object} frameworkReq This should be the request object generated by\n   *    the framework that you're using. But, really, it can be absolutely\n   *    anything, as this controller won't use it for anything except passing it\n   *    to user-provided functions that it calls (like transforms and id mappers).\n   * @param {Object} frameworkRes Theoretically, the response objcet generated\n   *     by your http framework but, like with frameworkReq, it can be anything.\n   */\n\n  _createClass(APIController, [{\n    key: \"handle\",\n    value: function handle(request, frameworkReq, frameworkRes) {\n      var response = new _typesHTTPResponse2[\"default\"]();\n      var registry = this.registry;\n\n      // Kick off the chain for generating the response.\n      return (0, _co2[\"default\"])(_regeneratorRuntime.mark(function callee$2$0() {\n        var parsedPrimary, mappedLabel, mappedIsEmptyArray, errorsArr, apiErrors;\n        return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n          while (1) switch (context$3$0.prev = context$3$0.next) {\n            case 0:\n              context$3$0.prev = 0;\n              context$3$0.next = 3;\n              return requestValidators.checkMethod(request);\n\n            case 3:\n              context$3$0.next = 5;\n              return requestValidators.checkBodyExistence(request);\n\n            case 5:\n              context$3$0.next = 7;\n              return (0, _stepsHttpContentNegotiationNegotiateContentType2[\"default\"])(request.accepts, [\"application/vnd.api+json\"]);\n\n            case 7:\n              response.contentType = context$3$0.sent;\n\n              // No matter what, though, we're varying on Accept. See:\n              // https://github.com/ethanresnick/json-api/issues/22\n              response.headers.vary = \"Accept\";\n\n              // If the type requested in the endpoint hasn't been registered, we 404.\n\n              if (registry.hasType(request.type)) {\n                context$3$0.next = 11;\n                break;\n              }\n\n              throw new _typesAPIError2[\"default\"](404, undefined, request.type + \" is not a valid type.\");\n\n            case 11:\n              if (!request.hasBody) {\n                context$3$0.next = 25;\n                break;\n              }\n\n              context$3$0.next = 14;\n              return (0, _stepsHttpContentNegotiationValidateContentType2[\"default\"])(request, supportedExt);\n\n            case 14:\n              context$3$0.next = 16;\n              return (0, _stepsPreQueryValidateDocument2[\"default\"])(request.body);\n\n            case 16:\n              context$3$0.next = 18;\n              return (0, _stepsPreQueryParseRequestPrimary2[\"default\"])(request.body.data, request.aboutRelationship);\n\n            case 18:\n              parsedPrimary = context$3$0.sent;\n\n              if (request.aboutRelationship) {\n                context$3$0.next = 22;\n                break;\n              }\n\n              context$3$0.next = 22;\n              return (0, _stepsPreQueryValidateResources2[\"default\"])(request.type, parsedPrimary, registry);\n\n            case 22:\n              context$3$0.next = 24;\n              return (0, _stepsApplyTransform2[\"default\"])(parsedPrimary, \"beforeSave\", registry, frameworkReq, frameworkRes);\n\n            case 24:\n              request.primary = context$3$0.sent;\n\n            case 25:\n              if (!(request.idOrIds && request.allowLabel)) {\n                context$3$0.next = 32;\n                break;\n              }\n\n              context$3$0.next = 28;\n              return (0, _stepsPreQueryLabelToIds2[\"default\"])(request.type, request.idOrIds, registry, frameworkReq);\n\n            case 28:\n              mappedLabel = context$3$0.sent;\n\n              // set the idOrIds on the request context\n              request.idOrIds = mappedLabel;\n\n              // if our new ids are null/undefined or an empty array, we can set\n              // the primary resources too! (Note: one could argue that we should\n              // 404 rather than return null when the label matches no ids.)\n              mappedIsEmptyArray = Array.isArray(mappedLabel) && !mappedLabel.length;\n\n              if (mappedLabel === null || mappedLabel === undefined || mappedIsEmptyArray) {\n                response.primary = mappedLabel ? new _typesCollection2[\"default\"]() : null;\n              }\n\n            case 32:\n              if (!(typeof response.primary === \"undefined\")) {\n                context$3$0.next = 47;\n                break;\n              }\n\n              context$3$0.t0 = request.method;\n              context$3$0.next = context$3$0.t0 === \"get\" ? 36 : context$3$0.t0 === \"post\" ? 39 : context$3$0.t0 === \"patch\" ? 42 : context$3$0.t0 === \"delete\" ? 45 : 47;\n              break;\n\n            case 36:\n              context$3$0.next = 38;\n              return (0, _stepsDoQueryDoGet2[\"default\"])(request, response, registry);\n\n            case 38:\n              return context$3$0.abrupt(\"break\", 47);\n\n            case 39:\n              context$3$0.next = 41;\n              return (0, _stepsDoQueryDoPost2[\"default\"])(request, response, registry);\n\n            case 41:\n              return context$3$0.abrupt(\"break\", 47);\n\n            case 42:\n              context$3$0.next = 44;\n              return (0, _stepsDoQueryDoPatch2[\"default\"])(request, response, registry);\n\n            case 44:\n              return context$3$0.abrupt(\"break\", 47);\n\n            case 45:\n              context$3$0.next = 47;\n              return (0, _stepsDoQueryDoDelete2[\"default\"])(request, response, registry);\n\n            case 47:\n              context$3$0.next = 55;\n              break;\n\n            case 49:\n              context$3$0.prev = 49;\n              context$3$0.t1 = context$3$0[\"catch\"](0);\n              errorsArr = Array.isArray(context$3$0.t1) ? context$3$0.t1 : [context$3$0.t1];\n              apiErrors = errorsArr.map(_typesAPIError2[\"default\"].fromError);\n\n              // Leave the error response's content type as JSON if we negotiated\n              // for that, but otherwise force it to JSON API, since that's the only\n              // other error format we know how to generate.\n              if (response.contentType !== \"application/json\") {\n                response.contentType = \"application/vnd.api+json\";\n              }\n\n              // Set the other key fields on the response\n              response.errors = response.errors.concat(apiErrors);\n              //console.log(\"API CONTROLLER ERRORS\", errorsArr[0], errorsArr[0].stack);\n\n            case 55:\n              if (!response.errors.length) {\n                context$3$0.next = 59;\n                break;\n              }\n\n              response.status = pickStatus(response.errors.map(function (v) {\n                return Number(v.status);\n              }));\n              response.body = new _typesDocument2[\"default\"](response.errors).get(true);\n              return context$3$0.abrupt(\"return\", response);\n\n            case 59:\n              context$3$0.next = 61;\n              return (0, _stepsApplyTransform2[\"default\"])(response.primary, \"beforeRender\", registry, frameworkReq, frameworkRes);\n\n            case 61:\n              response.primary = context$3$0.sent;\n              context$3$0.next = 64;\n              return (0, _stepsApplyTransform2[\"default\"])(response.included, \"beforeRender\", registry, frameworkReq, frameworkRes);\n\n            case 64:\n              response.included = context$3$0.sent;\n\n              if (response.status !== 204) {\n                response.body = new _typesDocument2[\"default\"](response.primary, response.included, undefined, registry.urlTemplates(), request.uri).get(true);\n              }\n\n              return context$3$0.abrupt(\"return\", response);\n\n            case 67:\n            case \"end\":\n              return context$3$0.stop();\n          }\n        }, callee$2$0, this, [[0, 49]]);\n      }));\n    }\n\n    /**\n     * Builds a response from errors. Allows errors that occur outside of the\n     * library to be handled and returned in JSON API-compiant fashion.\n     *\n     * @param {Error|APIError|Error[]|APIError[]} errors Error or array of errors\n     * @param {string} requestAccepts Request's Accepts header\n     */\n  }], [{\n    key: \"responseFromExternalError\",\n    value: function responseFromExternalError(errors, requestAccepts) {\n      var response = new _typesHTTPResponse2[\"default\"]();\n\n      // Convert to array\n      response.errors = Array.isArray(errors) ? errors : [errors];\n\n      // Convert Errors to APIErrors\n      response.errors = response.errors.map(_typesAPIError2[\"default\"].fromError.bind(_typesAPIError2[\"default\"]));\n\n      response.status = pickStatus(response.errors.map(function (v) {\n        return Number(v.status);\n      }));\n      response.body = new _typesDocument2[\"default\"](response.errors).get(true);\n\n      return (0, _stepsHttpContentNegotiationNegotiateContentType2[\"default\"])(requestAccepts, [\"application/vnd.api+json\"]).then(function (contentType) {\n        response.contentType = contentType.toLowerCase() === \"application/json\" ? contentType : \"application/vnd.api+json\";\n        return response;\n      }, function () {\n        // if we couldn't find any acceptable content-type,\n        // just ignore the accept header, as http allows.\n        response.contentType = \"application/vnd.api+json\";\n        return response;\n      });\n    }\n  }]);\n\n  return APIController;\n})();\n\nAPIController.supportedExt = supportedExt;\n\nexports[\"default\"] = APIController;\n\n/**\n * Returns the status code that best represents a set of error statuses.\n */\nfunction pickStatus(errStatuses) {\n  return errStatuses[0];\n}\nmodule.exports = exports[\"default\"];\n\n// check that a valid method is in use\n\n// throw if the body is supposed to be present but isn't (or vice-versa).\n\n// Try to negotiate the content type (may fail, and we may need to\n// deviate from the negotiated value if we have to return an error\n// body, rather than our expected response).\n\n// If the request has a body, validate it and parse its resources.\n\n// validate the request's resources.\n\n// Map label to idOrIds, if applicable.\n\n// Actually fulfill the request!\n// If we've already populated the primary resources, which is possible\n// because the label may have mapped to no id(s), we don't need to query.\n\n// Add errors to the response converting them, if necessary, to\n// APIError instances first. Might be needed if, e.g., the error was\n// unexpected (and so uncaught and not transformed) in one of prior steps\n// or the user couldn't throw an APIError for compatibility with other code.\n\n// If we have errors, which could have come from prior steps not just\n// throwing, return here and don't bother with transforms.\n\n// apply transforms pre-send","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/HTTP/Response.js":"\"use strict\";\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utilTypeHandling = require(\"../../util/type-handling\");\n\nvar propDesc = { writable: true, enumerable: true };\n\nvar Response = function Response() {\n  _classCallCheck(this, Response);\n\n  // The JSON-API extensions used to formulate the response,\n  // which affects the final the Content-Type header and our\n  // validation of the client's `Accept` header.\n  this.ext = [];\n\n  // The response's errors. If it has some,\n  // we render them instead of a standard document.\n  this.errors = [];\n\n  // The response's content type.\n  this.contentType = null;\n\n  // Other headers in the response.\n  this.headers = {\n    location: null,\n    vary: null\n  };\n\n  // The response's status.\n  this.status = null;\n\n  // The JSON for the response body, as a string.\n  // Down the line, this might allow for a stream.\n  this.body = null;\n\n  // The response's primary data. Have to use\n  // Object.defineProperty to default it to undefined\n  // while allowing us to set it post seal().\n  Object.defineProperty(this, \"primary\", propDesc);\n\n  // The response's included resources.\n  Object.defineProperty(this, \"included\", propDesc);\n\n  // The response document's top-level links.\n  Object.defineProperty(this, \"links\", propDesc);\n\n  // The response document's top-level meta information.\n  Object.defineProperty(this, \"meta\", propDesc);\n};\n\nexports[\"default\"] = (0, _utilTypeHandling.ValueObject)(Response);\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/http/validate-request.js":"\"use strict\";\n\nvar _Promise = require(\"babel-runtime/core-js/promise\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkBodyExistence = checkBodyExistence;\nexports.checkMethod = checkMethod;\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nfunction checkBodyExistence(requestContext) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    var needsBody = [\"post\", \"patch\"].indexOf(requestContext.method) !== -1 || requestContext.method === \"delete\" && requestContext.aboutRelationship || requestContext.method === \"delete\" && !requestContext.idOrIds && requestContext.ext.indexOf(\"bulk\") !== -1;\n\n    if (requestContext.hasBody === needsBody) {\n      resolve();\n    } else if (needsBody) {\n      reject(new _typesAPIError2[\"default\"](400, undefined, \"This request needs a body, but didn't have one.\"));\n    } else {\n      reject(new _typesAPIError2[\"default\"](400, undefined, \"This request should not have a body, but does.\"));\n    }\n  });\n}\n\nfunction checkMethod(_ref) {\n  var method = _ref.method;\n\n  if ([\"patch\", \"post\", \"delete\", \"get\"].indexOf(method) === -1) {\n    var detail = \"The method \\\"\" + method + \"\\\" is not supported.\" + (method === \"put\" ? \" See http://jsonapi.org/faq/#wheres-put\" : \"\");\n\n    return _Promise.reject(new _typesAPIError2[\"default\"](405, undefined, \"Method not supported.\", detail));\n  } else {\n    return _Promise.resolve();\n  }\n}","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/http/content-negotiation/negotiate-content-type.js":"\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _negotiator = require(\"negotiator\");\n\nvar _negotiator2 = _interopRequireDefault(_negotiator);\n\nvar _typesAPIError = require(\"../../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _utilTypeHandling = require(\"../../../util/type-handling\");\n\n/**\n * Negotiate the Content-Type to use for the response.\n *\n * More arguments may be added to the function later to support\n * negotiating on parameters for extensions.\n *\n * @param {String} acceptHeader The raw `Accept` header string from the client.\n * @param {Array[String]} availableBaseTypes A list of \"type/subtype\"\n *    representations, without that the server can produce for the\n *    requested resource.\n * @return {Promise} A Promise that resolves to the Content-Type to use,\n *    or false if no acceptable one exists.\n */\n\nexports[\"default\"] = function (acceptHeader, availableBaseTypes) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    var negotiator = new _negotiator2[\"default\"]({ headers: { accept: acceptHeader } });\n    var hasParams = function hasParams(it) {\n      return !(0, _utilTypeHandling.objectIsEmpty)(it.parameters);\n    };\n\n    // If an endpoint supports JSON API's media type, it implicity\n    // supports JSON too. Though we'll only respond with JSON if *necessary*.\n    var endpointSupportsJsonApi = availableBaseTypes.indexOf(\"application/vnd.api+json\") !== -1;\n    var syntheticAvailableBaseTypes = endpointSupportsJsonApi ? [\"application/json\"].concat(availableBaseTypes) : availableBaseTypes;\n\n    // Take a first stab at finding the preferred type with negotiator,\n    // but then we'll only use that type below if it's *not* json api,\n    // because we can't rely on negotiator to reason propery about parameters.\n    var acceptables = negotiator.mediaTypes(undefined, { \"detailed\": true });\n    var preferredType = negotiator.mediaType(syntheticAvailableBaseTypes);\n\n    // Find all the Accept clauses that specifically reference json api.\n    var jsonApiRanges = acceptables.filter(function (it) {\n      return it.type.toLowerCase() === \"application/vnd.api+json\";\n    });\n\n    // If we do have JSON API in the Accept header and all instances\n    // are parameterized, this is explicitly a 406.\n    if (jsonApiRanges.length && jsonApiRanges.every(hasParams)) {\n      reject(new _typesAPIError2[\"default\"](406, null, \"Not Acceptable\"));\n    }\n\n    // For everything but the JSON API media type, trust\n    // negotiator to handle things correctly.\n    else if (preferredType.toLowerCase() !== \"application/vnd.api+json\") {\n        resolve(preferredType);\n      }\n\n      // Otherwise, our preferred type is non existent or json api and, if it's\n      // json api, we have it unparameterized at least once.\n      else if (jsonApiRanges.length && endpointSupportsJsonApi) {\n          resolve(\"application/vnd.api+json\");\n        } else {\n          reject(new _typesAPIError2[\"default\"](406, null, \"Not Acceptable\"));\n        }\n  });\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/http/content-negotiation/validate-content-type.js":"\"use strict\";\n\nvar _Object$keys = require(\"babel-runtime/core-js/object/keys\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = validateContentType;\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _contentType = require(\"content-type\");\n\nvar _contentType2 = _interopRequireDefault(_contentType);\n\nvar _typesAPIError = require(\"../../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _utilTypeHandling = require(\"../../../util/type-handling\");\n\nfunction validateContentType(requestContext, supportedExt) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    var contentType = _contentType2[\"default\"].parse(requestContext.contentType);\n\n    // Removed due to issues with Firefox automatically adding charset parameter\n    // See: https://github.com/ethanresnick/json-api/issues/78\n    delete contentType.parameters.charset;\n\n    // In the future, we might delegate back to the framework if the client\n    // provides a base content type other than json-api's. But, for now, we 415.\n    if (contentType.type !== \"application/vnd.api+json\") {\n      var detail = \"The request's Content-Type must be application/vnd.api+json, \" + \"but you provided \" + contentType.type + \".\";\n\n      reject(new _typesAPIError2[\"default\"](415, undefined, \"Invalid Media Type\", detail));\n    } else if (!(0, _utilTypeHandling.objectIsEmpty)(contentType.parameters)) {\n      var detail = \"The request's Content-Type must be application/vnd.api+json, with \" + \"no parameters. But the Content-Type you provided contained the \" + (\"parameters: \" + _Object$keys(contentType.parameters).join(\", \") + \".\");\n\n      reject(new _typesAPIError2[\"default\"](415, undefined, \"Invalid Media Type Parameter(s)\", detail));\n    } else {\n      resolve();\n    }\n  });\n}\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/pre-query/label-to-ids.js":"\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nexports[\"default\"] = function (type, labelOrId, registry, frameworkReq) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    var adapter = registry.dbAdapter(type);\n    var model = adapter.getModel(adapter.constructor.getModelName(type));\n    var labelMappers = registry.labelMappers(type);\n    var labelMapper = labelMappers && labelMappers[labelOrId];\n\n    // reolve with the mapped label\n    if (typeof labelMapper === \"function\") {\n      (0, _q2[\"default\"])(labelMapper(model, frameworkReq)).then(resolve, reject);\n    }\n\n    // or, if we couldn't find a label mapper, that means\n    // we were given an id, so we just resolve with that id.\n    else {\n        resolve(labelOrId);\n      }\n  });\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/pre-query/parse-request-primary.js":"\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _typesResource = require(\"../../types/Resource\");\n\nvar _typesResource2 = _interopRequireDefault(_typesResource);\n\nvar _typesRelationship = require(\"../../types/Relationship\");\n\nvar _typesRelationship2 = _interopRequireDefault(_typesRelationship);\n\nvar _typesLinkage = require(\"../../types/Linkage\");\n\nvar _typesLinkage2 = _interopRequireDefault(_typesLinkage);\n\nvar _typesCollection = require(\"../../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nexports[\"default\"] = function (data, parseAsLinkage) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    try {\n      if (parseAsLinkage) {\n        resolve(linkageFromJSON(data));\n      } else if (Array.isArray(data)) {\n        resolve(new _typesCollection2[\"default\"](data.map(resourceFromJSON)));\n      } else {\n        resolve(resourceFromJSON(data));\n      }\n    } catch (error) {\n      if (error instanceof _typesAPIError2[\"default\"]) {\n        reject(error);\n      } else {\n        var title = \"The resources you provided could not be parsed.\";\n        var details = \"The precise error was: \\\"\" + error.message + \"\\\".\";\n        reject(new _typesAPIError2[\"default\"](400, undefined, title, details));\n      }\n    }\n  });\n};\n\nfunction relationshipFromJSON(json) {\n  if (typeof json.data === \"undefined\") {\n    throw new _typesAPIError2[\"default\"](400, undefined, \"Missing relationship linkage.\");\n  }\n\n  return new _typesRelationship2[\"default\"](linkageFromJSON(json.data));\n}\n\nfunction linkageFromJSON(json) {\n  return new _typesLinkage2[\"default\"](json);\n}\n\nfunction resourceFromJSON(json) {\n  var relationships = json.relationships || {};\n\n  //build Relationships\n  var key = undefined;\n  try {\n    for (key in relationships) {\n      relationships[key] = relationshipFromJSON(relationships[key], key);\n    }\n  } catch (e) {\n    e.details = \"No data was found for the \" + key + \" relationship.\";\n    throw e;\n  }\n\n  return new _typesResource2[\"default\"](json.type, json.id, json.attributes, relationships, json.meta);\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/pre-query/validate-document.js":"\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nexports[\"default\"] = function (body) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    var ownProp = Object.prototype.hasOwnProperty;\n    var errMessage = \"Request body is not a valid JSON API document.\";\n\n    if (typeof body !== \"object\" || !ownProp.call(body, \"data\")) {\n      reject(new _typesAPIError2[\"default\"](400, null, errMessage));\n    } else {\n      resolve();\n    }\n  });\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/pre-query/validate-resources.js":"\"use strict\";\n\nvar _Object$keys = require(\"babel-runtime/core-js/object/keys\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _utilTypeHandling = require(\"../../util/type-handling\");\n\nvar _utilMisc = require(\"../../util/misc\");\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nexports[\"default\"] = function (endpointParentType, resourceOrCollection, registry) {\n  return _q2[\"default\"].Promise(function (resolve, reject) {\n    // validate that all resources are of types appropriate for the endpoint.\n    var adapter = registry.dbAdapter(endpointParentType);\n    var allowedTypes = adapter.getTypesAllowedInCollection(endpointParentType);\n    var resourcesByType = (0, _utilTypeHandling.groupResourcesByType)(resourceOrCollection);\n\n    if (!(0, _utilMisc.isSubsetOf)(allowedTypes, _Object$keys(resourcesByType))) {\n      var title = \"Some of the resources you provided are of a type that \" + \"doesn't belong in this collection.\";\n      var detail = \"Valid types for this collection are: \" + allowedTypes.join(\", \") + \".\";\n\n      reject(new _typesAPIError2[\"default\"](400, undefined, title, detail));\n    } else {\n      var _loop = function (type) {\n        var resources = resourcesByType[type];\n        var relationshipNames = adapter.getRelationshipNames(type);\n\n        /*eslint-disable no-loop-func */\n        var invalid = resources.some(function (resource) {\n          return relationshipNames.some(function (relationshipName) {\n            return typeof resource.attrs[relationshipName] !== \"undefined\";\n          });\n        });\n        /*eslint-enable no-loop-func */\n\n        if (invalid) {\n          var title = \"Relationship fields must be specified under the `relationships` key.\";\n          return {\n            v: reject(new _typesAPIError2[\"default\"](400, undefined, title))\n          };\n        }\n      };\n\n      // If there are extra attributes or missing attributes, we want the\n      // adapter to decide how to handle that, depending on the model. But,\n      // if there are paths that must be relationship names listed under the\n      // attributes, that's a case that we can identify here and throw for.\n      for (var type in resourcesByType) {\n        var _ret = _loop(type);\n\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n\n      return resolve();\n    }\n  });\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/apply-transform.js":"\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typesResource = require(\"../types/Resource\");\n\nvar _typesResource2 = _interopRequireDefault(_typesResource);\n\nvar _typesCollection = require(\"../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nvar _q = require(\"q\");\n\n/**\n * @param toTransform Could be a single resource, a collection, a link object, or null.\n */\n\nexports[\"default\"] = function (toTransform, mode, registry, frameworkReq, frameworkRes) {\n  if (toTransform instanceof _typesResource2[\"default\"]) {\n    return transform(toTransform, frameworkReq, frameworkRes, mode, registry);\n  } else if (toTransform instanceof _typesCollection2[\"default\"]) {\n    // below, allow the user to return undefined to remove a vlaue.\n    return _q.Promise.all(toTransform.resources.map(function (it) {\n      return transform(it, frameworkReq, frameworkRes, mode, registry);\n    })).then(function (transformed) {\n      return new _typesCollection2[\"default\"](transformed.filter(function (it) {\n        return it !== undefined;\n      }));\n    });\n  }\n\n  // We only transform resources or collections.\n  else {\n      return _q.Promise.resolve(toTransform);\n    }\n};\n\nfunction transform(resource, req, res, transformMode, registry) {\n  var transformFn = registry[transformMode](resource.type);\n\n  // SuperFn is a function that the first transformer can invoke.\n  // It'll return the resource passed in (i.e. do nothing) if there\n  // is no parentType or the parentType doesn't define an appropriate\n  // transformer. Otherwise, it'll return the result of calling\n  // the parentType's transformer with the provided arguments.\n  var superFn = function superFn(resource, req, res) {\n    // eslint-disable-line no-shadow\n    var parentType = registry.parentType(resource.type);\n\n    if (!parentType || !registry[transformMode](parentType)) {\n      return resource;\n    } else {\n      return registry[transformMode](parentType)(resource, req, res, superFn);\n    }\n  };\n\n  if (!transformFn) {\n    return _q.Promise.resolve(resource);\n  }\n\n  // Allow user to return a Promise or a value\n  var transformed = transformFn(resource, req, res, superFn);\n  return _q.Promise.resolve(transformed);\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/do-query/do-get.js":"\"use strict\";\n\nvar _slicedToArray = require(\"babel-runtime/helpers/sliced-to-array\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _utilArrays = require(\"../../util/arrays\");\n\nexports[\"default\"] = function (requestContext, responseContext, registry) {\n  var type = requestContext.type;\n  var adapter = registry.dbAdapter(type);\n  var fields = undefined,\n      sorts = undefined,\n      includes = undefined,\n      filters = undefined;\n\n  // Handle fields, sorts, includes and filters.\n  if (!requestContext.aboutRelationship) {\n    fields = parseFields(requestContext.queryParams.fields);\n    sorts = parseCommaSeparatedParam(requestContext.queryParams.sort);\n    // just support a \"simple\" filtering strategy for now.\n    filters = requestContext.queryParams.filter && requestContext.queryParams.filter.simple;\n    includes = parseCommaSeparatedParam(requestContext.queryParams.include);\n\n    if (!includes) {\n      includes = registry.defaultIncludes(type);\n    }\n\n    return adapter.find(type, requestContext.idOrIds, fields, sorts, filters, includes).then(function (resources) {\n      var _resources = _slicedToArray(resources, 2);\n\n      responseContext.primary = _resources[0];\n      responseContext.included = _resources[1];\n    });\n  }\n\n  // the user's asking for linkage. In this case:\n  // - fields don't apply because fields only pick out members of resource\n  //   objects, and here we're not returning a resource object;\n  // - includes don't apply because the path names for an includes must match\n  //   those in the primary data's `links` key, and this primary data doesn't\n  //   have a links key.\n  // - sorts don't apply beacuse that's only for resource collections.\n  else {\n      if (Array.isArray(requestContext.idOrIds)) {\n        throw new _typesAPIError2[\"default\"](400, undefined, \"You can only request the linkage for one resource at a time.\");\n      }\n\n      return adapter.find(type, requestContext.idOrIds).spread(function (resource) {\n        // 404 if the requested relationship is not a relationship path. Doing\n        // it here is more accurate than using adapter.getRelationshipNames,\n        // since we're allowing for paths that can optionally hold linkage,\n        // which getRelationshipNames doesn't return.\n        var relationship = resource.relationships && resource.relationships[requestContext.relationship];\n\n        if (!relationship) {\n          var title = \"Invalid relationship name.\";\n          var detail = requestContext.relationship + \" is not a valid \" + (\"relationship name on resources of type '\" + type + \"'\");\n\n          throw new _typesAPIError2[\"default\"](404, undefined, title, detail);\n        }\n\n        responseContext.primary = relationship.linkage;\n      });\n    }\n};\n\nfunction parseFields(fieldsParam) {\n  var fields = undefined;\n  if (typeof fieldsParam === \"object\") {\n    fields = {};\n    var isField = function isField(it) {\n      return !(0, _utilArrays.arrayContains)([\"id\", \"type\"], it);\n    };\n\n    for (var type in fieldsParam) {\n      var provided = parseCommaSeparatedParam(fieldsParam[type]) || [];\n      fields[type] = provided.filter(isField);\n    }\n  }\n  return fields;\n}\n\nfunction parseCommaSeparatedParam(it) {\n  return it ? it.split(\",\").map(decodeURIComponent) : undefined;\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/do-query/do-post.js":"\"use strict\";\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _typesResource = require(\"../../types/Resource\");\n\nvar _typesResource2 = _interopRequireDefault(_typesResource);\n\nvar _typesLinkage = require(\"../../types/Linkage\");\n\nvar _typesLinkage2 = _interopRequireDefault(_typesLinkage);\n\nvar _urlTemplate = require(\"url-template\");\n\nvar _urlTemplate2 = _interopRequireDefault(_urlTemplate);\n\nvar _utilTypeHandling = require(\"../../util/type-handling\");\n\nexports[\"default\"] = function (requestContext, responseContext, registry) {\n  var primary = requestContext.primary;\n  var type = requestContext.type;\n  var adapter = registry.dbAdapter(type);\n\n  // We're going to do an adapter.create, below, EXCEPT if we're adding to\n  // an existing toMany relationship, which uses a different adapter method.\n  if (primary instanceof _typesLinkage2[\"default\"]) {\n    if (!Array.isArray(primary.value)) {\n      throw new _typesAPIError2[\"default\"](400, undefined, \"To add to a to-many relationship, you must POST an array of linkage objects.\");\n    }\n\n    return adapter.addToRelationship(type, requestContext.idOrIds, requestContext.relationship, primary).then(function () {\n      responseContext.status = 204;\n    });\n  } else {\n    var _ret = (function () {\n      var noClientIds = \"Client-generated ids are not supported.\";\n      (0, _utilTypeHandling.forEachResources)(primary, function (it) {\n        if (it.id) throw new _typesAPIError2[\"default\"](403, undefined, noClientIds);\n      });\n\n      return {\n        v: adapter.create(type, primary).then(function (created) {\n          responseContext.primary = created;\n          responseContext.status = 201;\n\n          // We can only generate a Location url for a single resource.\n          if (created instanceof _typesResource2[\"default\"]) {\n            var templates = registry.urlTemplates(created.type);\n            var template = templates && templates.self;\n            if (template) {\n              var templateData = _Object$assign({ \"id\": created.id }, created.attrs);\n              responseContext.headers.location = _urlTemplate2[\"default\"].parse(template).expand(templateData);\n            }\n          }\n        })\n      };\n    })();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/do-query/do-patch.js":"\"use strict\";\n\nvar _defineProperty = require(\"babel-runtime/helpers/define-property\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _typesCollection = require(\"../../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nvar _typesResource = require(\"../../types/Resource\");\n\nvar _typesResource2 = _interopRequireDefault(_typesResource);\n\nvar _typesRelationship = require(\"../../types/Relationship\");\n\nvar _typesRelationship2 = _interopRequireDefault(_typesRelationship);\n\nvar _typesLinkage = require(\"../../types/Linkage\");\n\nvar _typesLinkage2 = _interopRequireDefault(_typesLinkage);\n\nexports[\"default\"] = function (requestContext, responseContext, registry) {\n  var primary = requestContext.primary;\n  var type = requestContext.type;\n  var adapter = registry.dbAdapter(type);\n  var changedResourceOrCollection = undefined;\n\n  if (primary instanceof _typesCollection2[\"default\"]) {\n    if (requestContext.idOrIds && !Array.isArray(requestContext.idOrIds)) {\n      var title = \"You can't replace a single resource with a collection.\";\n      throw new _typesAPIError2[\"default\"](400, undefined, title);\n    }\n\n    changedResourceOrCollection = primary;\n  } else if (primary instanceof _typesResource2[\"default\"]) {\n    if (!requestContext.idOrIds) {\n      var title = \"You must provide an array of resources to do a bulk update.\";\n      throw new _typesAPIError2[\"default\"](400, undefined, title);\n    } else if (requestContext.idOrIds !== primary.id) {\n      var title = \"The id of the resource you provided doesn't match that in the URL.\";\n      throw new _typesAPIError2[\"default\"](400, undefined, title);\n    }\n    changedResourceOrCollection = primary;\n  } else if (primary instanceof _typesLinkage2[\"default\"]) {\n    changedResourceOrCollection = new _typesResource2[\"default\"](requestContext.type, requestContext.idOrIds, undefined, _defineProperty({}, requestContext.relationship, new _typesRelationship2[\"default\"](requestContext.primary)));\n  }\n\n  return adapter.update(type, changedResourceOrCollection).then(function (resources) {\n\n    responseContext.primary = primary instanceof _typesLinkage2[\"default\"] ? resources.relationships[requestContext.relationship].linkage : resources;\n  });\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/steps/do-query/do-delete.js":"\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _typesCollection = require(\"../../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nexports[\"default\"] = function (request, response, registry) {\n  var type = request.type;\n  var adapter = registry.dbAdapter(type);\n\n  if (request.aboutRelationship) {\n    if (Array.isArray(request.idOrIds)) {\n      throw new _typesAPIError2[\"default\"](400, undefined, \"You can only remove resources from the linkage of one resource at a time.\");\n    }\n    return adapter.removeFromRelationship(type, request.idOrIds, request.relationship, request.primary).then(function () {\n      response.status = 204;\n    });\n  } else if (!request.idOrIds && request.ext.indexOf(\"bulk\") !== -1) {\n    if (!(request.primary instanceof _typesCollection2[\"default\"])) {\n      var title = \"You must provide an array of objects to do a bulk delete.\";\n      throw new _typesAPIError2[\"default\"](400, undefined, title);\n    }\n\n    if (!request.primary.resources.every(function (it) {\n      return typeof it.id !== \"undefined\";\n    })) {\n      var title = \"Every object provided for a bulk delete must contain a `type` and `id`.\";\n      throw new _typesAPIError2[\"default\"](400, undefined, title);\n    }\n\n    var ids = request.primary.resources.map(function (it) {\n      return it.id;\n    });\n    return adapter[\"delete\"](request.type, ids).then(function () {\n      response.status = 204;\n    });\n  } else {\n    return adapter[\"delete\"](type, request.idOrIds).then(function () {\n      response.status = 204;\n    });\n  }\n};\n\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/controllers/Documentation.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _Object$setPrototypeOf = require(\"babel-runtime/core-js/object/set-prototype-of\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _lodash = require(\"lodash\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _jade = require(\"jade\");\n\nvar _jade2 = _interopRequireDefault(_jade);\n\nvar _negotiator = require(\"negotiator\");\n\nvar _negotiator2 = _interopRequireDefault(_negotiator);\n\nvar _dasherize = require(\"dasherize\");\n\nvar _dasherize2 = _interopRequireDefault(_dasherize);\n\nvar _lodashObjectMapValues = require(\"lodash/object/mapValues\");\n\nvar _lodashObjectMapValues2 = _interopRequireDefault(_lodashObjectMapValues);\n\nvar _typesHTTPResponse = require(\"../types/HTTP/Response\");\n\nvar _typesHTTPResponse2 = _interopRequireDefault(_typesHTTPResponse);\n\nvar _typesDocument = require(\"../types/Document\");\n\nvar _typesDocument2 = _interopRequireDefault(_typesDocument);\n\nvar _typesCollection = require(\"../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nvar _typesResource = require(\"../types/Resource\");\n\nvar _typesResource2 = _interopRequireDefault(_typesResource);\n\nvar DocumentationController = (function () {\n  function DocumentationController(registry, apiInfo, templatePath) {\n    var _this = this;\n\n    var dasherizeJSONKeys = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n    _classCallCheck(this, DocumentationController);\n\n    this.registry = registry;\n\n    var defaultTempPath = \"../../../templates/documentation.jade\";\n    this.template = templatePath || _path2[\"default\"].resolve(__dirname, defaultTempPath);\n\n    this.dasherizeJSONKeys = dasherizeJSONKeys;\n\n    // compute template data on construction\n    // (it never changes, so this makes more sense than doing it per request)\n    var data = _Object$assign({}, apiInfo);\n    data.resourcesMap = {};\n\n    // Store in the resourcesMap the info object about each type,\n    // as returned by @getTypeInfo.\n    this.registry.typeNames().forEach(function (typeName) {\n      data.resourcesMap[typeName] = _this.getTypeInfo(typeName);\n    });\n\n    this.templateData = data;\n  }\n\n  /**\n   * A function to pass to _.cloneDeep to customize the result.\n   * Basically, it \"pseudo-constructs\" new instances of any objects\n   * that were instantiated with custom classes/constructor functions\n   * before. It does this by making a plain object version of the\n   * instance (i.e. it's local state as captured by it's enumerable\n   * own properties) and setting the `.constructor` and [[Prototype]]\n   * on that plain object. This isn't identical to constructing a new\n   * instance of course, which could have other side-effects (and also\n   * effects super() binding on real ES6 classes), but it's better than\n   * just using a plain object.\n   */\n\n  _createClass(DocumentationController, [{\n    key: \"handle\",\n    value: function handle(request, frameworkReq, frameworkRes) {\n      var _this2 = this;\n\n      var response = new _typesHTTPResponse2[\"default\"]();\n      var negotiator = new _negotiator2[\"default\"]({ headers: { accept: request.accepts } });\n      var contentType = negotiator.mediaType([\"text/html\", \"application/vnd.api+json\"]);\n\n      // set content type as negotiated & vary on accept.\n      response.contentType = contentType;\n      response.headers.vary = \"Accept\";\n\n      // process templateData (just the type infos for now) for this particular request.\n      var templateData = _lodash2[\"default\"].cloneDeep(this.templateData, cloneCustomizer);\n      templateData.resourcesMap = (0, _lodashObjectMapValues2[\"default\"])(templateData.resourcesMap, function (typeInfo, typeName) {\n        return _this2.transformTypeInfo(typeName, typeInfo, request, response, frameworkReq, frameworkRes);\n      });\n\n      if (contentType.toLowerCase() === \"text/html\") {\n        response.body = _jade2[\"default\"].renderFile(this.template, templateData);\n      } else {\n        // Create a collection of \"jsonapi-descriptions\" from the templateData\n        var descriptionResources = new _typesCollection2[\"default\"]();\n\n        // Add a description resource for each resource type to the collection.\n        for (var type in templateData.resourcesMap) {\n          descriptionResources.add(new _typesResource2[\"default\"](\"jsonapi-descriptions\", type, templateData.resourcesMap[type]));\n        }\n\n        response.body = new _typesDocument2[\"default\"](descriptionResources).get(true);\n      }\n\n      return (0, _q2[\"default\"])(response);\n    }\n\n    // Clients can extend this if, say, the adapter can't infer\n    // as much info about the models' structure as they would like.\n  }, {\n    key: \"getTypeInfo\",\n    value: function getTypeInfo(type) {\n      var adapter = this.registry.dbAdapter(type);\n      var modelName = adapter.constructor.getModelName(type);\n      var model = adapter.getModel(modelName);\n\n      // Combine the docs in the Resource description with the standardized schema\n      // from the adapter in order to build the final schema for the template.\n      var info = this.registry.info(type);\n      var schema = adapter.constructor.getStandardizedSchema(model);\n      var ucFirst = function ucFirst(v) {\n        return v.charAt(0).toUpperCase() + v.slice(1);\n      };\n\n      schema.forEach(function (field) {\n        // look up user defined field info on info.fields.\n        var pathInfo = info && info.fields && info.fields[field.name] || {};\n\n        // Keys that have a meaning in the default template.\n        var overrideableKeys = [\"friendlyName\", \"kind\", \"description\"];\n\n        for (var key in pathInfo) {\n          // allow the user to override auto-generated friendlyName and the\n          // auto-generated type info, which is undefined for virtuals. Also,\n          // allow them to set the description, which is always user-provided.\n          // And, finally, copy in any other info properties that don't\n          // conflict with ones defined by this library.\n          if (overrideableKeys.indexOf(key) > -1 || !(key in field)) {\n            field[key] = pathInfo[key];\n          }\n\n          // If the current info key does conflict (i.e. `key in field`), but\n          // the user-provided value is an object, try to merge in the object's\n          // properties. If the key conflicts and doesn't hold an object into\n          // which we can merge, we just give up (i.e. we don't try anything\n          // else after the below).\n          else if (typeof field[key] === \"object\" && !Array.isArray(field[key])) {\n              _Object$assign(field[key], pathInfo[key]);\n            }\n        }\n      });\n      // Other info\n      var result = {\n        name: {\n          \"model\": modelName,\n          \"singular\": adapter.constructor.toFriendlyName(modelName),\n          \"plural\": type.split(\"-\").map(ucFirst).join(\" \")\n        },\n        fields: schema,\n        parentType: this.registry.parentType(type),\n        childTypes: adapter.constructor.getChildTypes(model)\n      };\n\n      var defaultIncludes = this.registry.defaultIncludes(type);\n      if (defaultIncludes) result.defaultIncludes = defaultIncludes;\n\n      if (info && info.example) result.example = info.example;\n      if (info && info.description) result.description = info.description;\n\n      return result;\n    }\n\n    /**\n     * By extending this function, users have an opportunity to transform\n     * the documentation info for each type based on the particulars of the\n     * current request. This is useful, among other things, for showing\n     * users documentation only for models they have access to, and it lays\n     * the groundwork for true HATEOS intro pages in the future.\n     */\n  }, {\n    key: \"transformTypeInfo\",\n    value: function transformTypeInfo(typeName, info, request, response, frameworkReq, frameworkRes) {\n      if (this.dasherizeJSONKeys && response.contentType === \"application/vnd.api+json\") {\n        return (0, _dasherize2[\"default\"])(info);\n      }\n      return info;\n    }\n  }]);\n\n  return DocumentationController;\n})();\n\nexports[\"default\"] = DocumentationController;\nfunction cloneCustomizer(value) {\n  if (isCustomObject(value)) {\n    var state = _lodash2[\"default\"].cloneDeep(value);\n    _Object$setPrototypeOf(state, Object.getPrototypeOf(value));\n    Object.defineProperty(state, \"constructor\", {\n      \"writable\": true,\n      \"enumerable\": false,\n      \"value\": value.constructor\n    });\n\n    // handle the possibiliy that a key in state was itself a non-plain object\n    for (var key in state) {\n      if (isCustomObject(value[key])) {\n        state[key] = _lodash2[\"default\"].cloneDeep(value[key], cloneCustomizer);\n      }\n    }\n\n    return state;\n  }\n\n  return undefined;\n}\n\nfunction isCustomObject(v) {\n  return v && typeof v === \"object\" && v.constructor !== Object && !Array.isArray(v);\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/ResourceTypeRegistry.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _Symbol = require(\"babel-runtime/core-js/symbol\")[\"default\"];\n\nvar _Object$keys = require(\"babel-runtime/core-js/object/keys\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _utilMisc = require(\"./util/misc\");\n\nvar _utilTypeHandling = require(\"./util/type-handling\");\n\n/**\n * A private array of properties that will be used by the class below to\n * automatically generate simple getters for each property, all following the\n * same format. Those getters will take the name of the resource type whose\n * property is being retrieved.\n */\nvar autoGetterProps = [\"dbAdapter\", \"beforeSave\", \"beforeRender\", \"behaviors\", \"labelMappers\", \"defaultIncludes\", \"info\", \"parentType\"];\n\n/**\n * Global defaults for all resource descriptions, to be merged into the\n * defaults provided to the ResourceTypeRegistry, which are in turn merged\n * into the values provided in each resource type description.\n */\nvar globalResourceDefaults = _immutable2[\"default\"].fromJS({\n  behaviors: {\n    dasherizeOutput: { enabled: true }\n  }\n});\n\nvar typesKey = _Symbol();\n\n/**\n * To fulfill a JSON API request, you often need to know about all the resources\n * types in the system--not just the type that is the primary target of the\n * request. For example, if the request is for a User (or Users), you might need\n * to include related Projects, so the code handling the users request needs\n * access to the Project resource's beforeSave and beforeRender methods; its\n * url templates; etc. So we handle this by introducing a ResourceTypeRegistry\n * that the Controller can have access to. Each resource type is registered by\n * its JSON API type and has a number of properties defining it.\n */\n\nvar ResourceTypeRegistry = (function () {\n  function ResourceTypeRegistry() {\n    var _this = this;\n\n    var typeDescriptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var descriptionDefaults = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, ResourceTypeRegistry);\n\n    this[typesKey] = {};\n    descriptionDefaults = globalResourceDefaults.mergeDeep(descriptionDefaults);\n\n    // Sort the types so we can register them in an order that respects their\n    // parentType. First, we pre-process the typeDescriptions to create edges\n    // pointing to each node's children (rather than the links we have by\n    // default, which point to the parent). Then we do an abridged topological\n    // sort that works in this case. Below, nodes is a list of type names.\n    // Roots are nodes with no parents. Edges is a map, with each key being the\n    // name of a starting node A, and the value being a set of node names for\n    // which there is an edge from A to that node.\n    var nodes = [],\n        roots = [],\n        edges = {};\n\n    for (var typeName in typeDescriptions) {\n      var nodeParentType = typeDescriptions[typeName].parentType;\n      nodes.push(typeName);\n\n      if (nodeParentType) {\n        edges[nodeParentType] = edges[nodeParentType] || {};\n        edges[nodeParentType][typeName] = true;\n      } else {\n        roots.push(typeName);\n      }\n    }\n\n    var typeRegistrationOrder = (0, _utilMisc.pseudoTopSort)(nodes, edges, roots);\n\n    // register the types, in order\n    typeRegistrationOrder.forEach(function (typeName) {\n      var parentType = typeDescriptions[typeName].parentType;\n\n      // defaultIncludes need to be made into an object if they came as an array.\n      // TODO: Remove support for array format before v3. It's inconsistent.\n      var thisDescriptionRaw = _immutable2[\"default\"].fromJS(typeDescriptions[typeName]);\n      var thisDescriptionMerged = descriptionDefaults.mergeDeep(thisDescriptionRaw);\n\n      _this[typesKey][typeName] = parentType ?\n      // If we have a parentType, we merge in all the parent's fields,\n      // BUT we then overwrite labelMappers with just the ones directly\n      // from this description. We don't inherit labelMappers because a\n      // labelMapper is a kind of filter, and the results of a filter\n      // on the parent type may not be instances of the subtype.\n      _this[typesKey][parentType].mergeDeep(thisDescriptionRaw).set(\"labelMappers\", thisDescriptionRaw.get(\"labelMappers\")) :\n\n      // If we don't have a parentType, just register\n      // the description merged with the universal defaults\n      thisDescriptionMerged;\n    });\n  }\n\n  _createClass(ResourceTypeRegistry, [{\n    key: \"type\",\n    value: function type(typeName) {\n      return (0, _utilTypeHandling.Maybe)(this[typesKey][typeName]).bind(function (it) {\n        return it.toJS();\n      }).unwrap();\n    }\n  }, {\n    key: \"hasType\",\n    value: function hasType(typeName) {\n      return typeName in this[typesKey];\n    }\n  }, {\n    key: \"typeNames\",\n    value: function typeNames() {\n      return _Object$keys(this[typesKey]);\n    }\n  }, {\n    key: \"urlTemplates\",\n    value: function urlTemplates(type) {\n      var _this2 = this;\n\n      if (type) {\n        return (0, _utilTypeHandling.Maybe)(this[typesKey][type]).bind(function (it) {\n          return it.get(\"urlTemplates\");\n        }).bind(function (it) {\n          return it.toJS();\n        }).unwrap();\n      }\n\n      return _Object$keys(this[typesKey]).reduce(function (prev, typeName) {\n        prev[typeName] = _this2.urlTemplates(typeName);\n        return prev;\n      }, {});\n    }\n  }]);\n\n  return ResourceTypeRegistry;\n})();\n\nexports[\"default\"] = ResourceTypeRegistry;\n\nautoGetterProps.forEach(function (propName) {\n  ResourceTypeRegistry.prototype[propName] = makeGetter(propName);\n});\n\nfunction makeGetter(attrName) {\n  return function (type) {\n    return (0, _utilTypeHandling.Maybe)(this[typesKey][type]).bind(function (it) {\n      return it.get(attrName);\n    }).bind(function (it) {\n      return it instanceof _immutable2[\"default\"].Map || it instanceof _immutable2[\"default\"].List ? it.toJS() : it;\n    }).unwrap();\n  };\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/db-adapters/Mongoose/MongooseAdapter.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _defineProperty = require(\"babel-runtime/helpers/define-property\")[\"default\"];\n\nvar _slicedToArray = require(\"babel-runtime/helpers/sliced-to-array\")[\"default\"];\n\nvar _Object$keys = require(\"babel-runtime/core-js/object/keys\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _mongoose = require(\"mongoose\");\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _utilArrays = require(\"../../util/arrays\");\n\nvar _utilMisc = require(\"../../util/misc\");\n\nvar _utilTypeHandling = require(\"../../util/type-handling\");\n\nvar _lib = require(\"./lib\");\n\nvar util = _interopRequireWildcard(_lib);\n\nvar _pluralize = require(\"pluralize\");\n\nvar _pluralize2 = _interopRequireDefault(_pluralize);\n\nvar _typesResource = require(\"../../types/Resource\");\n\nvar _typesResource2 = _interopRequireDefault(_typesResource);\n\nvar _typesCollection = require(\"../../types/Collection\");\n\nvar _typesCollection2 = _interopRequireDefault(_typesCollection);\n\nvar _typesLinkage = require(\"../../types/Linkage\");\n\nvar _typesLinkage2 = _interopRequireDefault(_typesLinkage);\n\nvar _typesRelationship = require(\"../../types/Relationship\");\n\nvar _typesRelationship2 = _interopRequireDefault(_typesRelationship);\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _typesDocumentationField = require(\"../../types/Documentation/Field\");\n\nvar _typesDocumentationField2 = _interopRequireDefault(_typesDocumentationField);\n\nvar _typesDocumentationFieldType = require(\"../../types/Documentation/FieldType\");\n\nvar _typesDocumentationFieldType2 = _interopRequireDefault(_typesDocumentationFieldType);\n\nvar _typesDocumentationRelationshipType = require(\"../../types/Documentation/RelationshipType\");\n\nvar _typesDocumentationRelationshipType2 = _interopRequireDefault(_typesDocumentationRelationshipType);\n\nvar MongooseAdapter = (function () {\n  function MongooseAdapter(models, inflector, idGenerator) {\n    _classCallCheck(this, MongooseAdapter);\n\n    this.models = models || _mongoose2[\"default\"].models;\n    this.inflector = inflector || _pluralize2[\"default\"];\n    this.idGenerator = idGenerator;\n  }\n\n  /**\n   * Returns a Promise for an array of two items: the primary resources (either\n   * a single Resource or a Collection) and the included resources, as an array.\n   *\n   * Note: The correct behavior if idOrIds is an empty array is to return no\n   * documents, as happens below. If it's undefined, though, we're not filtering\n   * by id and should return all documents.\n   */\n\n  _createClass(MongooseAdapter, [{\n    key: \"find\",\n    value: function find(type, idOrIds, fields, sorts, filters, includePaths) {\n      var _this = this;\n\n      var model = this.getModel(this.constructor.getModelName(type));\n      var queryBuilder = new _mongoose2[\"default\"].Query(null, null, model, model.collection);\n\n      var _constructor$getIdQueryType = this.constructor.getIdQueryType(idOrIds);\n\n      var _constructor$getIdQueryType2 = _slicedToArray(_constructor$getIdQueryType, 2);\n\n      var mode = _constructor$getIdQueryType2[0];\n      var idQuery = _constructor$getIdQueryType2[1];\n\n      var pluralizer = this.inflector.plural;\n      var primaryDocumentsPromise = undefined,\n          includedResourcesPromise = (0, _q2[\"default\"])(null);\n\n      queryBuilder[mode](idQuery);\n\n      // do sorting\n      if (Array.isArray(sorts)) {\n        queryBuilder.sort(sorts.join(\" \"));\n      }\n\n      // filter out invalid records with simple fields equality.\n      // note that there's a non-trivial risk of sql-like injection here.\n      // we're mostly protected by the fact that we're treating the filter's\n      // value as a single string, though, and not parsing as JSON.\n      if (typeof filters === \"object\" && !Array.isArray(filters)) {\n        queryBuilder.where(filters);\n      }\n\n      // in an ideal world, we'd use mongoose here to filter the fields before\n      // querying. But, because the fields to filter can be scoped by type and\n      // we don't always know about a document's type until after query (becuase\n      // of discriminator keys), and because filtering out fields can really\n      // complicate population for includes, we don't yet filter at query time but\n      // instead just hide filtered fields in @docToResource. There is a more-\n      // efficient way to do this down the road, though--something like taking the\n      // provided fields and expanding them just enough (by looking at the type\n      // heirarachy and the relationship paths) to make sure that we're not going\n      // to run into any of the problems outlined above, while still querying for\n      // less data than we would without any fields restriction. For reference, the\n      // code for safely using the user's `fields` input, by putting them into a\n      // mongoose `.select()` object so that the user can't prefix a field with a\n      // minus on input to affect the query, is below.\n      // Reference: http://mongoosejs.com/docs/api.html#query_Query-select.\n      // let arrToSelectObject = (prev, curr) => { prev[curr] = 1; return prev; };\n      // for(let type in fields) {\n      //   fields[type] = fields[type].reduce(arrToSelectObject, {});\n      // }\n\n      // support includes, but only a level deep for now (recursive includes,\n      // especially if done in an efficient way query wise, are a pain in the ass).\n      if (includePaths) {\n        (function () {\n          var populatedPaths = [];\n          var refPaths = util.getReferencePaths(model);\n\n          includePaths = includePaths.map(function (it) {\n            return it.split(\".\");\n          });\n          includePaths.forEach(function (pathParts) {\n            // first, check that the include path is valid.\n            if (!(0, _utilArrays.arrayContains)(refPaths, pathParts[0])) {\n              var title = \"Invalid include path.\";\n              var detail = \"Resources of type \\\"\" + type + \"\\\" don't have a(n) \\\"\" + pathParts[0] + \"\\\" relationship.\";\n              throw new _typesAPIError2[\"default\"](400, undefined, title, detail);\n            }\n\n            if (pathParts.length > 1) {\n              throw new _typesAPIError2[\"default\"](501, undefined, \"Multi-level include paths aren't yet supported.\");\n            }\n\n            // Finally, do the population\n            populatedPaths.push(pathParts[0]);\n            queryBuilder.populate(pathParts[0]);\n          });\n\n          var includedResources = [];\n          primaryDocumentsPromise = (0, _q2[\"default\"])(queryBuilder.exec()).then(function (docs) {\n            (0, _utilTypeHandling.forEachArrayOrVal)(docs, function (doc) {\n              // There's no gaurantee that the doc (or every doc) was found\n              // and we can't populate paths on a non-existent doc.\n              if (!doc) return;\n\n              populatedPaths.forEach(function (path) {\n                // if it's a toOne relationship, doc[path] will be a doc or undefined;\n                // if it's a toMany relationship, we have an array (or undefined).\n                var refDocs = Array.isArray(doc[path]) ? doc[path] : [doc[path]];\n                refDocs.forEach(function (it) {\n                  // only include if it's not undefined.\n                  if (it) {\n                    includedResources.push(_this.constructor.docToResource(it, pluralizer, fields));\n                  }\n                });\n              });\n            });\n\n            return docs;\n          });\n\n          includedResourcesPromise = primaryDocumentsPromise.then(function () {\n            return new _typesCollection2[\"default\"](includedResources);\n          });\n        })();\n      } else {\n        primaryDocumentsPromise = (0, _q2[\"default\"])(queryBuilder.exec());\n      }\n\n      return _q2[\"default\"].all([primaryDocumentsPromise.then(function (it) {\n        var makeCollection = !idOrIds || Array.isArray(idOrIds) ? true : false;\n        return _this.constructor.docsToResourceOrCollection(it, makeCollection, pluralizer, fields);\n      }), includedResourcesPromise])[\"catch\"](util.errorHandler);\n    }\n\n    /**\n     * Returns a Promise that fulfills with the created Resource. The Promise\n     * may also reject with an error if creation failed or was unsupported.\n     *\n     * @param {string} parentType - All the resources to be created must be this\n     *   type or be sub-types of it.\n     * @param {(Resource|Collection)} resourceOrCollection - The resource or\n     *   collection of resources to create.\n     */\n  }, {\n    key: \"create\",\n    value: function create(parentType, resourceOrCollection) {\n      var _this2 = this;\n\n      var resourcesByType = (0, _utilTypeHandling.groupResourcesByType)(resourceOrCollection);\n\n      // Note: creating the resources as we do below means that we do one\n      // query for each type, as opposed to only one query for all of the\n      // documents. That's unfortunately much slower, but it ensures that\n      // mongoose runs all the user's hooks.\n      var creationPromises = [];\n      var setIdWithGenerator = function setIdWithGenerator(doc) {\n        doc._id = _this2.idGenerator(doc);\n      };\n      for (var type in resourcesByType) {\n        var model = this.getModel(this.constructor.getModelName(type));\n        var resources = resourcesByType[type];\n        var docObjects = resources.map(util.resourceToDocObject);\n\n        if (typeof this.idGenerator === \"function\") {\n          (0, _utilTypeHandling.forEachArrayOrVal)(docObjects, setIdWithGenerator);\n        }\n\n        creationPromises.push(_q2[\"default\"].ninvoke(model, \"create\", docObjects));\n      }\n\n      return _q2[\"default\"].all(creationPromises).then(function (docArrays) {\n        var makeCollection = resourceOrCollection instanceof _typesCollection2[\"default\"];\n        var finalDocs = docArrays.reduce(function (a, b) {\n          return a.concat(b);\n        }, []);\n        return _this2.constructor.docsToResourceOrCollection(finalDocs, makeCollection, _this2.inflector.plural);\n      })[\"catch\"](util.errorHandler);\n    }\n\n    /**\n     * @param {string} parentType - All the resources to be created must be this\n     *   type or be sub-types of it.\n     * @param {Object} resourceOrCollection - The changed Resource or Collection\n     *   of resources. Should only have the fields that are changed.\n     */\n  }, {\n    key: \"update\",\n    value: function update(parentType, resourceOrCollection) {\n      var _this3 = this;\n\n      // It'd be faster to bypass Mongoose Document creation & just have mongoose\n      // send a findAndUpdate command directly to mongo, but we want Mongoose's\n      // standard validation and lifecycle hooks, and so we have to find first.\n      // Note that, starting in Mongoose 4, we'll be able to run the validations\n      // on update, which should be enough, so we won't need to find first.\n      // https://github.com/Automattic/mongoose/issues/860\n      var model = this.getModel(this.constructor.getModelName(parentType));\n      var singular = this.inflector.singular;\n      var plural = this.inflector.plural;\n\n      // Set up some data structures based on resourcesOrCollection\n      var resourceTypes = [];\n      var changeSets = {};\n\n      var idOrIds = (0, _utilTypeHandling.mapResources)(resourceOrCollection, function (it) {\n        changeSets[it.id] = it;\n        resourceTypes.push(it.type);\n        return it.id;\n      });\n\n      var _constructor$getIdQueryType3 = this.constructor.getIdQueryType(idOrIds);\n\n      var _constructor$getIdQueryType32 = _slicedToArray(_constructor$getIdQueryType3, 2);\n\n      var mode = _constructor$getIdQueryType32[0];\n      var idQuery = _constructor$getIdQueryType32[1];\n\n      return (0, _q2[\"default\"])(model[mode](idQuery).exec()).then(function (docs) {\n        var successfulSavesPromises = [];\n\n        // if some ids were invalid/deleted/not found, we can't let *any* update\n        // succeed. this is the beginning of our simulation of transactions.\n        // There are two types of invalid cases here: we looked up one or more\n        // docs and got none back (i.e. docs === null) or we looked up an array of\n        // docs and got back docs that were missing some requested ids.\n        if (docs === null) {\n          throw new _typesAPIError2[\"default\"](404, undefined, \"No matching resource found.\");\n        } else {\n          var idOrIdsAsArray = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n          var docIdOrIdsAsArray = Array.isArray(docs) ? docs.map(function (it) {\n            return it.id;\n          }) : [docs.id];\n\n          if (!(0, _utilArrays.arrayValuesMatch)(idOrIdsAsArray, docIdOrIdsAsArray)) {\n            var title = \"Some of the resources you're trying to update could not be found.\";\n            throw new _typesAPIError2[\"default\"](404, undefined, title);\n          }\n        }\n\n        (0, _utilTypeHandling.forEachArrayOrVal)(docs, function (currDoc) {\n          var newResource = changeSets[currDoc.id];\n\n          // Allowing the type to change is a bit of a pain. If the type's\n          // changed, it means the mongoose Model representing the doc must be\n          // different too. So we have to get the data from the old doc with\n          // .toObject(), change its discriminator, and then create an instance\n          // of the new model with that data. We also have to mark that new\n          // instance as not representing a new document, so that mongoose will\n          // do an update query rather than a save. Finally, we have to do all\n          // this before updating other attributes, so that they're correctly\n          // marked as modified when changed.\n          var currentModelName = currDoc.constructor.modelName;\n          var newModelName = _this3.constructor.getModelName(newResource.type, singular);\n          if (currentModelName !== newModelName) {\n            var newDoc = currDoc.toObject({ virtuals: true, getters: true });\n            var NewModelConstructor = _this3.getModel(newModelName);\n            newDoc[currDoc.constructor.schema.options.discriminatorKey] = newModelName;\n\n            // replace the currDoc with our new creation.\n            currDoc = new NewModelConstructor(newDoc);\n            currDoc.isNew = false;\n          }\n\n          // update all attributes and links provided, ignoring type/meta/id.\n          currDoc.set(util.resourceToDocObject(newResource));\n\n          successfulSavesPromises.push(_q2[\"default\"].Promise(function (resolve, reject) {\n            currDoc.save(function (err, doc) {\n              if (err) reject(err);\n              resolve(doc);\n            });\n          }));\n        });\n\n        return _q2[\"default\"].all(successfulSavesPromises);\n      }).then(function (docs) {\n        var makeCollection = resourceOrCollection instanceof _typesCollection2[\"default\"];\n        return _this3.constructor.docsToResourceOrCollection(docs, makeCollection, plural);\n      })[\"catch\"](util.errorHandler);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(parentType, idOrIds) {\n      var model = this.getModel(this.constructor.getModelName(parentType));\n\n      var _constructor$getIdQueryType4 = this.constructor.getIdQueryType(idOrIds);\n\n      var _constructor$getIdQueryType42 = _slicedToArray(_constructor$getIdQueryType4, 2);\n\n      var mode = _constructor$getIdQueryType42[0];\n      var idQuery = _constructor$getIdQueryType42[1];\n\n      if (!idOrIds) {\n        return _q2[\"default\"].Promise(function (resolve, reject) {\n          reject(new _typesAPIError2[\"default\"](400, undefined, \"You must specify some resources to delete\"));\n        });\n      }\n\n      return (0, _q2[\"default\"])(model[mode](idQuery).exec()).then(function (docs) {\n        if (!docs) throw new _typesAPIError2[\"default\"](404, undefined, \"No matching resource found.\");\n        (0, _utilTypeHandling.forEachArrayOrVal)(docs, function (it) {\n          it.remove();\n        });\n        return docs;\n      })[\"catch\"](util.errorHandler);\n    }\n\n    /**\n     * Unlike update(), which would do full replacement of a to-many relationship\n     * if new linkage was provided, this method adds the new linkage to the existing\n     * relationship. It doesn't do a find-then-save, so some mongoose hooks may not\n     * run. But validation and the update query hooks will work if you're using\n     * Mongoose 4.0.\n     */\n  }, {\n    key: \"addToRelationship\",\n    value: function addToRelationship(type, id, relationshipPath, newLinkage) {\n      var model = this.getModel(this.constructor.getModelName(type));\n      var update = {\n        $addToSet: _defineProperty({}, relationshipPath, { $each: newLinkage.value.map(function (it) {\n            return it.id;\n          }) })\n      };\n      var options = { runValidators: true };\n\n      return _q2[\"default\"].ninvoke(model, \"findOneAndUpdate\", { \"_id\": id }, update, options)[\"catch\"](util.errorHandler);\n    }\n  }, {\n    key: \"removeFromRelationship\",\n    value: function removeFromRelationship(type, id, relationshipPath, linkageToRemove) {\n      var model = this.getModel(this.constructor.getModelName(type));\n      var update = {\n        $pullAll: _defineProperty({}, relationshipPath, linkageToRemove.value.map(function (it) {\n          return it.id;\n        }))\n      };\n      var options = { runValidators: true };\n\n      return _q2[\"default\"].ninvoke(model, \"findOneAndUpdate\", { \"_id\": id }, update, options)[\"catch\"](util.errorHandler);\n    }\n  }, {\n    key: \"getModel\",\n    value: function getModel(modelName) {\n      if (!this.models[modelName]) {\n        // don't use an APIError here, since we don't want to\n        // show this internals-specific method to the user.\n        var err = new Error(\"The model \\\"\" + modelName + \"\\\" has not been registered with the MongooseAdapter.\");\n        err.status = 404;\n        throw err;\n      }\n      return this.models[modelName];\n    }\n  }, {\n    key: \"getTypesAllowedInCollection\",\n    value: function getTypesAllowedInCollection(parentType) {\n      var parentModel = this.getModel(this.constructor.getModelName(parentType, this.inflector.singular));\n      return [parentType].concat(this.constructor.getChildTypes(parentModel, this.inflector.plural));\n    }\n\n    /**\n     * Return the paths that, for the provided type, must always must be filled\n     * with relationship info, if they're present. Occassionally, a path might be\n     * optionally fillable w/ relationship info; this shouldn't return those paths.\n     */\n  }, {\n    key: \"getRelationshipNames\",\n    value: function getRelationshipNames(type) {\n      var model = this.getModel(this.constructor.getModelName(type, this.inflector.singular));\n      return util.getReferencePaths(model);\n    }\n\n    /**\n     * We want to always return a collection when the user is asking for something\n     * that's logically a Collection (even if it only has 1 item), and a Resource\n     * otherwise. But, because mongoose returns a single doc if you query for a\n     * one-item array of ids, and because we sometimes generate arrays (e.g. of\n     * promises for documents' successful creation) even when only creating/updating\n     * one document, just looking at whether docs is an array isn't enough to tell\n     * us whether to return a collection or not. And, in all these cases, we want\n     * to handle the possibility that the query returned no documents when we needed\n     * one, such that we must 404. This function centralizes all that logic.\n     *\n     * @param docs The docs to turn into a resource or collection\n     * @param makeCollection Whether we're making a collection.\n     * @param pluralizer An inflector function for setting the Resource's type\n     */\n  }], [{\n    key: \"docsToResourceOrCollection\",\n    value: function docsToResourceOrCollection(docs, makeCollection, pluralizer, fields) {\n      var _this4 = this;\n\n      // if docs is an empty array and we're making a collection, that's ok.\n      // but, if we're looking for a single doc, we must 404 if we didn't find any.\n      if (!docs || !makeCollection && Array.isArray(docs) && docs.length === 0) {\n        throw new _typesAPIError2[\"default\"](404, undefined, \"No matching resource found.\");\n      }\n\n      docs = !Array.isArray(docs) ? [docs] : docs;\n      docs = docs.map(function (it) {\n        return _this4.docToResource(it, pluralizer, fields);\n      });\n      return makeCollection ? new _typesCollection2[\"default\"](docs) : docs[0];\n    }\n\n    // Useful to have this as static for calling as a utility outside this class.\n  }, {\n    key: \"docToResource\",\n    value: function docToResource(doc, pluralizer, fields) {\n      var _this5 = this;\n\n      if (pluralizer === undefined) pluralizer = _pluralize2[\"default\"].plural;\n\n      var type = this.getType(doc.constructor.modelName, pluralizer);\n      var refPaths = util.getReferencePaths(doc.constructor);\n      var schemaOptions = doc.constructor.schema.options;\n\n      // Get and clean up attributes\n      // Note: we can't use the depopulate attribute because it doesn't just\n      // depopulate fields _inside_ the passed in doc, but can actually turn the\n      // doc itself into a string if the doc was originally gotten by population.\n      // That's stupid, and it breaks our include handling.\n      // Also, starting in 4.0, we won't need the delete versionKey line:\n      // https://github.com/Automattic/mongoose/issues/2675\n      var attrs = doc.toJSON({ virtuals: true, getters: true });\n      delete attrs.id; // from the id virtual.\n      delete attrs._id;\n      delete attrs[schemaOptions.versionKey];\n      delete attrs[schemaOptions.discriminatorKey];\n\n      // Delete attributes that aren't in the included fields.\n      // TODO: Some virtuals could be expensive to compute, so, if field\n      // restrictions are in use, we shouldn't set {virtuals: true} above and,\n      // instead, we should read only the virtuals that are needed (by searching\n      // the schema to identify the virtual paths and then checking those against\n      // fields) and add them to newAttrs.\n      if (fields && fields[type]) {\n        (function () {\n          var newAttrs = {};\n          fields[type].forEach(function (field) {\n            if (attrs[field]) {\n              newAttrs[field] = attrs[field];\n            }\n          });\n          attrs = newAttrs;\n        })();\n      }\n\n      // Build relationships\n      var relationships = {};\n      var getProp = function getProp(obj, part) {\n        return obj[part];\n      };\n\n      refPaths.forEach(function (path) {\n        // skip if applicable\n        if (fields && fields[type] && !(0, _utilArrays.arrayContains)(fields[type], path)) {\n          return;\n        }\n\n        // get value at the path w/ the reference, in both the json'd + full docs.\n        var pathParts = path.split(\".\");\n        var jsonValAtPath = pathParts.reduce(getProp, attrs);\n        var referencedType = _this5.getReferencedType(doc.constructor, path);\n\n        // delete the attribute, since we're moving it to relationships\n        (0, _utilMisc.deleteNested)(path, attrs);\n\n        // Now, since the value wasn't excluded, we need to build its\n        // Relationship. Note: the value could still be null or an empty array.\n        // And, because of population, it could be a single document or array of\n        // documents, in addition to a single/array of ids. So, as is customary,\n        // we'll start by coercing it to an array no matter what, tracking\n        // whether to make it a non-array at the end, to simplify our code.\n        var isToOneRelationship = false;\n\n        if (!Array.isArray(jsonValAtPath)) {\n          jsonValAtPath = [jsonValAtPath];\n          isToOneRelationship = true;\n        }\n\n        var linkage = [];\n        jsonValAtPath.forEach(function (docOrIdOrNull) {\n          var idOrNull = undefined;\n\n          // if it has an ._id key, it's a document.\n          if (docOrIdOrNull && docOrIdOrNull._id) {\n            idOrNull = String(docOrIdOrNull._id);\n          } else {\n            // Even though we did toJSON(), id may be an ObjectId. (lame.)\n            idOrNull = docOrIdOrNull ? String(docOrIdOrNull) : null;\n          }\n\n          linkage.push(idOrNull ? { type: referencedType, id: idOrNull } : null);\n        });\n\n        // go back from an array if neccessary and save.\n        linkage = new _typesLinkage2[\"default\"](isToOneRelationship ? linkage[0] : linkage);\n        relationships[path] = new _typesRelationship2[\"default\"](linkage);\n      });\n\n      // finally, create the resource.\n      return new _typesResource2[\"default\"](type, doc.id, attrs, relationships);\n    }\n  }, {\n    key: \"getModelName\",\n    value: function getModelName(type) {\n      var singularizer = arguments.length <= 1 || arguments[1] === undefined ? _pluralize2[\"default\"].singular : arguments[1];\n\n      var words = type.split(\"-\");\n      words[words.length - 1] = singularizer(words[words.length - 1]);\n      return words.map(function (it) {\n        return it.charAt(0).toUpperCase() + it.slice(1);\n      }).join(\"\");\n    }\n\n    // Get the json api type name for a model.\n  }, {\n    key: \"getType\",\n    value: function getType(modelName) {\n      var pluralizer = arguments.length <= 1 || arguments[1] === undefined ? _pluralize2[\"default\"].plural : arguments[1];\n\n      return pluralizer(modelName.replace(/([A-Z])/g, \"\\-$1\").slice(1).toLowerCase());\n    }\n  }, {\n    key: \"getReferencedType\",\n    value: function getReferencedType(model, path) {\n      var pluralizer = arguments.length <= 2 || arguments[2] === undefined ? _pluralize2[\"default\"].plural : arguments[2];\n\n      return this.getType(util.getReferencedModelName(model, path), pluralizer);\n    }\n  }, {\n    key: \"getChildTypes\",\n    value: function getChildTypes(model) {\n      var _this6 = this;\n\n      var pluralizer = arguments.length <= 1 || arguments[1] === undefined ? _pluralize2[\"default\"].plural : arguments[1];\n\n      if (!model.discriminators) return [];\n\n      return _Object$keys(model.discriminators).map(function (it) {\n        return _this6.getType(it, pluralizer);\n      });\n    }\n  }, {\n    key: \"getStandardizedSchema\",\n    value: function getStandardizedSchema(model) {\n      var _this7 = this;\n\n      var pluralizer = arguments.length <= 1 || arguments[1] === undefined ? _pluralize2[\"default\"].plural : arguments[1];\n\n      var schemaOptions = model.schema.options;\n      var versionKey = schemaOptions.versionKey;\n      var discriminatorKey = schemaOptions.discriminatorKey;\n      var virtuals = model.schema.virtuals;\n      var schemaFields = [];\n\n      var getFieldType = function getFieldType(path, schemaType) {\n        if (path === \"_id\") {\n          return new _typesDocumentationFieldType2[\"default\"](\"Id\", false);\n        }\n\n        var typeOptions = schemaType.options.type;\n        var holdsArray = Array.isArray(typeOptions);\n        var baseType = holdsArray ? typeOptions[0].type.name : typeOptions.name;\n        var refModelName = util.getReferencedModelName(model, path);\n\n        return !refModelName ? new _typesDocumentationFieldType2[\"default\"](baseType, holdsArray) : new _typesDocumentationRelationshipType2[\"default\"](holdsArray, refModelName, _this7.getType(refModelName, pluralizer));\n      };\n\n      model.schema.eachPath(function (name, type) {\n        if ((0, _utilArrays.arrayContains)([versionKey, discriminatorKey], name)) {\n          return;\n        }\n\n        var fieldType = getFieldType(name, type);\n        name = name === \"_id\" ? \"id\" : name;\n        var likelyAutoGenerated = name === \"id\" || fieldType.baseType === \"Date\" && /created|updated|modified/.test(name) && typeof type.options[\"default\"] === \"function\";\n\n        var defaultVal = undefined;\n        if (likelyAutoGenerated) {\n          defaultVal = \"__AUTO__\";\n        } else if (type.options[\"default\"] && typeof type.options[\"default\"] !== \"function\") {\n          defaultVal = type.options[\"default\"];\n        }\n\n        // find the \"base type's\" options (used below), in case\n        // we have an array of values of the same type at this path.\n        var baseTypeOptions = Array.isArray(type.options.type) ? type.options.type[0] : type.options;\n\n        // Add validation info\n        var validationRules = {\n          required: !!type.options.required,\n          oneOf: baseTypeOptions[\"enum\"] ? type.enumValues || type.caster && type.caster.enumValues : undefined,\n          max: type.options.max || undefined\n        };\n\n        type.validators.forEach(function (validatorObj) {\n          _Object$assign(validationRules, validatorObj.validator.JSONAPIDocumentation);\n        });\n\n        schemaFields.push(new _typesDocumentationField2[\"default\"](name, fieldType, validationRules, _this7.toFriendlyName(name), defaultVal));\n      });\n\n      for (var virtual in virtuals) {\n        // skip the id virtual, since we properly handled _id above.\n        if (virtual === \"id\") {\n          continue;\n        }\n\n        // for virtual properties, we can't infer type or validation rules at all,\n        // so we add them with just a friendly name and leave the rest undefined.\n        // The user is expected to override/set this in a resource type description.\n        schemaFields.push(new _typesDocumentationField2[\"default\"](virtual, undefined, undefined, this.toFriendlyName(virtual)));\n      }\n      return schemaFields;\n    }\n  }, {\n    key: \"toFriendlyName\",\n    value: function toFriendlyName(pathOrModelName) {\n      var ucFirst = function ucFirst(v) {\n        return v.charAt(0).toUpperCase() + v.slice(1);\n      };\n\n      // pascal case is \"upper camel case\", i.e. \"MyName\" as opposed to \"myName\".\n      // this variable holds a normalized, pascal cased version of pathOrModelName,\n      // such that `ModelFormat`, `pathFormat` `nested.path.format` all become\n      // ModelFormat, PathFormat, and NestedPathFormat.\n      var pascalCasedString = pathOrModelName.split(\".\").map(ucFirst).join(\"\");\n\n      // Now, to handle acronyms like InMLBTeam, we need to define a word as a\n      // capital letter, plus (0 or more capital letters where the capital letter\n      // is not followed by a non-capital letter or 0 or more non capital letters).\n      var matches = undefined;\n      var words = [];\n      var wordsRe = /[A-Z]([A-Z]*(?![^A-Z])|[^A-Z]*)/g;\n\n      while ((matches = wordsRe.exec(pascalCasedString)) !== null) {\n        words.push(matches[0]);\n      }\n\n      return words.join(\" \");\n    }\n  }, {\n    key: \"getIdQueryType\",\n    value: function getIdQueryType(idOrIds) {\n      var mode = typeof idOrIds === \"string\" ? \"findOne\" : \"find\";\n      var idQuery = undefined;\n\n      if (typeof idOrIds === \"string\") {\n        if (!this.idIsValid(idOrIds)) {\n          throw new _typesAPIError2[\"default\"](404, undefined, \"No matching resource found.\", \"Invalid ID.\");\n        }\n\n        idQuery = { _id: idOrIds };\n      } else if (Array.isArray(idOrIds)) {\n        if (!idOrIds.every(this.idIsValid)) {\n          throw new _typesAPIError2[\"default\"](400, undefined, \"Invalid ID.\");\n        }\n\n        idQuery = { _id: { \"$in\": idOrIds } };\n      }\n\n      return [mode, idQuery];\n    }\n  }, {\n    key: \"idIsValid\",\n    value: function idIsValid(id) {\n      return typeof id === \"string\" && /^[0-9a-fA-F]{24}$/.test(id);\n    }\n  }]);\n\n  return MongooseAdapter;\n})();\n\nexports[\"default\"] = MongooseAdapter;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/db-adapters/Mongoose/lib.js":"// This file contains utility functions used by the Mongoose adapter that\n// aren't part of the class's public interface. Don't use them in your own\n// code, as their APIs are subject to change.\n\"use strict\";\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.errorHandler = errorHandler;\nexports.getReferencePaths = getReferencePaths;\nexports.isReferencePath = isReferencePath;\nexports.getReferencedModelName = getReferencedModelName;\nexports.resourceToDocObject = resourceToDocObject;\n\nvar _typesAPIError = require(\"../../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\n/**\n * Takes any error that resulted from the above operations throws an array of\n * errors that can be sent back to the caller as the Promise's rejection value.\n */\n\nfunction errorHandler(err) {\n  var errors = [];\n  //Convert validation errors collection to something reasonable\n  if (err.errors) {\n    for (var errKey in err.errors) {\n      var thisError = err.errors[errKey];\n      errors.push(new _typesAPIError2[\"default\"](err.name === \"ValidationError\" ? 400 : thisError.status || 500, undefined, thisError.message, undefined, undefined, thisError.path ? [thisError.path] : undefined));\n    }\n  }\n\n  // Send the raw error.\n  // Don't worry about revealing internal concerns, as the pipeline maps\n  // all unhandled errors to generic json-api APIError objects pre responding.\n  else {\n      errors.push(err);\n    }\n\n  throw errors;\n}\n\nfunction getReferencePaths(model) {\n  var paths = [];\n  model.schema.eachPath(function (name, type) {\n    if (isReferencePath(type)) paths.push(name);\n  });\n  return paths;\n}\n\nfunction isReferencePath(schemaType) {\n  var options = (schemaType.caster || schemaType).options;\n  return options && options.ref !== undefined;\n}\n\nfunction getReferencedModelName(model, path) {\n  var schemaType = model.schema.path(path);\n  var schemaOptions = (schemaType.caster || schemaType).options;\n  return schemaOptions && schemaOptions.ref;\n}\n\n/**\n * Takes a Resource object and returns JSON that could be passed to Mongoose\n * to create a document for that resource. The returned JSON doesn't include\n * the id (as the input resources are coming from a client, and we're\n * ignoring client-provided ids) or the type (as that is set by mongoose\n * outside of the document) or the meta (as storing that like a field may not\n * be what we want to do).\n */\n\nfunction resourceToDocObject(resource) {\n  var res = _Object$assign({}, resource.attrs);\n  var getId = function getId(it) {\n    return it.id;\n  };\n  for (var key in resource.relationships) {\n    var linkage = resource.relationships[key].linkage.value;\n\n    // handle linkage when set explicitly for empty relationships\n    if (linkage === null || Array.isArray(linkage) && linkage.length === 0) {\n      res[key] = linkage;\n    } else {\n      res[key] = Array.isArray(linkage) ? linkage.map(getId) : linkage.id;\n    }\n  }\n  return res;\n}","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/Documentation/RelationshipType.js":"\"use strict\";\n\nvar _get = require(\"babel-runtime/helpers/get\")[\"default\"];\n\nvar _inherits = require(\"babel-runtime/helpers/inherits\")[\"default\"];\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _FieldType2 = require(\"./FieldType\");\n\nvar _FieldType3 = _interopRequireDefault(_FieldType2);\n\nvar RelationshipType = (function (_FieldType) {\n  _inherits(RelationshipType, _FieldType);\n\n  function RelationshipType(toMany, targetModel, targetType) {\n    _classCallCheck(this, RelationshipType);\n\n    _get(Object.getPrototypeOf(RelationshipType.prototype), \"constructor\", this).call(this, \"Relationship\", toMany);\n    var _ref = [targetModel, targetType];\n    this.targetModel = _ref[0];\n    this.targetType = _ref[1];\n  }\n\n  _createClass(RelationshipType, [{\n    key: \"toString\",\n    value: function toString() {\n      return (this.isArray ? \"Array[\" : \"\") + this.targetModel + \"Id\" + (this.isArray ? \"]\" : \"\");\n    }\n  }]);\n\n  return RelationshipType;\n})(_FieldType3[\"default\"]);\n\nexports[\"default\"] = RelationshipType;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/http-strategies/Express.js":"\"use strict\";\n\nvar _get = require(\"babel-runtime/helpers/get\")[\"default\"];\n\nvar _inherits = require(\"babel-runtime/helpers/inherits\")[\"default\"];\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _vary = require(\"vary\");\n\nvar _vary2 = _interopRequireDefault(_vary);\n\nvar _controllersAPI = require(\"../controllers/API\");\n\nvar _controllersAPI2 = _interopRequireDefault(_controllersAPI);\n\nvar _Base2 = require(\"./Base\");\n\nvar _Base3 = _interopRequireDefault(_Base2);\n\n/**\n * This controller receives requests directly from express and sends responses\n * directly through it, but it converts incoming requests to, and generates\n * responses, from Request and Response objects that are defined by this\n * framework in a way that's not particular to express. This controller thereby\n * acts as a translation-layer between express and the rest of this json-api\n * framework.\n *\n * @param {Object} options A set of configuration options.\n *\n * @param {boolean} options.tunnel Whether to turn on PATCH tunneling. See:\n *    http://jsonapi.org/recommendations/#patchless-clients\n *\n * @param {boolean} options.handleContentNegotiation If the JSON API library\n *    can't produce a representation for the response that the client can\n *    `Accept`, should it return 406 or should it hand the request back to\n *    Express (i.e. call next()) so that subsequent handlers can attempt to\n *    find an alternate representation? By default, it does the former. But you\n *    can set this option to false to have this code just pass on to Express.\n */\n\nvar ExpressStrategy = (function (_Base) {\n  _inherits(ExpressStrategy, _Base);\n\n  function ExpressStrategy(apiController, docsController, options) {\n    _classCallCheck(this, ExpressStrategy);\n\n    _get(Object.getPrototypeOf(ExpressStrategy.prototype), \"constructor\", this).call(this, apiController, docsController, options);\n  }\n\n  // For requests like GET /:type, GET /:type/:id/:relationship,\n  // POST /:type PATCH /:type/:id, PATCH /:type, DELETE /:type/:idOrLabel,\n  // DELETE /:type, GET /:type/:id/links/:relationship,\n  // PATCH /:type/:id/links/:relationship, POST /:type/:id/links/:relationship,\n  // and DELETE /:type/:id/links/:relationship.\n\n  _createClass(ExpressStrategy, [{\n    key: \"apiRequest\",\n    value: function apiRequest(req, res, next) {\n      var _this = this;\n\n      this.buildRequestObject(req, req.protocol, req.get(\"Host\"), req.params, req.query).then(function (requestObject) {\n        return _this.api.handle(requestObject, req, res).then(function (responseObject) {\n          _this.sendResources(responseObject, res, next);\n        });\n      })[\"catch\"](function (err) {\n        _this.sendError(err, req, res);\n      });\n    }\n\n    // For requests for the documentation.\n  }, {\n    key: \"docsRequest\",\n    value: function docsRequest(req, res, next) {\n      var _this2 = this;\n\n      this.buildRequestObject(req, req.protocol, req.get(\"Host\"), req.params, req.query).then(function (requestObject) {\n        return _this2.docs.handle(requestObject, req, res).then(function (responseObject) {\n          _this2.sendResources(responseObject, res, next);\n        });\n      })[\"catch\"](function (err) {\n        _this2.sendError(err, req, res);\n      });\n    }\n  }, {\n    key: \"sendResources\",\n    value: function sendResources(responseObject, res, next) {\n      if (responseObject.headers.vary) {\n        (0, _vary2[\"default\"])(res, responseObject.headers.vary);\n      }\n\n      if (!responseObject.contentType) {\n        if (this.config.handleContentNegotiation) {\n          res.status(406).send();\n        } else {\n          next();\n        }\n      } else {\n        res.set(\"Content-Type\", responseObject.contentType);\n        res.status(responseObject.status || 200);\n\n        if (responseObject.headers.location) {\n          res.set(\"Location\", responseObject.headers.location);\n        }\n\n        if (responseObject.body !== null) {\n          res.send(new Buffer(responseObject.body)).end();\n        } else {\n          res.end();\n        }\n      }\n    }\n\n    /**\n     * A user of this library may wish to send an error response for an exception\n     * that originated outside of the JSON API Pipeline and that's outside the\n     * main spec's scope (e.g. an authentication error). So, the controller\n     * exposes this method which allows them to do that.\n     *\n     * @param {Error|APIError|Error[]|APIError[]} errors Error or array of errors\n     * @param {Object} req Express's request object\n     * @param {Object} res Express's response object\n     */\n  }, {\n    key: \"sendError\",\n    value: function sendError(errors, req, res) {\n      var _this3 = this;\n\n      _controllersAPI2[\"default\"].responseFromExternalError(errors, req.headers.accept).then(function (responseObject) {\n        return _this3.sendResources(responseObject, res, function () {});\n      })[\"catch\"](function (err) {\n        // if we hit an error generating our error...\n        res.status(err.status).send(err.message);\n      });\n    }\n\n    /**\n     * @TODO Uses this ExpressStrategy to create an express app with\n     * preconfigured routes that can be mounted as a subapp.\n    toApp(typesToExcludedMethods) {\n    }\n    */\n  }]);\n\n  return ExpressStrategy;\n})(_Base3[\"default\"]);\n\nexports[\"default\"] = ExpressStrategy;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/http-strategies/Base.js":"\"use strict\";\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _Object$assign = require(\"babel-runtime/core-js/object/assign\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _q = require(\"q\");\n\nvar _q2 = _interopRequireDefault(_q);\n\nvar _qs = require(\"qs\");\n\nvar _qs2 = _interopRequireDefault(_qs);\n\nvar _contentType = require(\"content-type\");\n\nvar _contentType2 = _interopRequireDefault(_contentType);\n\nvar _rawBody = require(\"raw-body\");\n\nvar _rawBody2 = _interopRequireDefault(_rawBody);\n\nvar _typesAPIError = require(\"../types/APIError\");\n\nvar _typesAPIError2 = _interopRequireDefault(_typesAPIError);\n\nvar _typesHTTPRequest = require(\"../types/HTTP/Request\");\n\nvar _typesHTTPRequest2 = _interopRequireDefault(_typesHTTPRequest);\n\n/**\n * This controller is the base for http strategy classes. It's built around\n * the premise that most if not all http frameworks are built on top of the\n * core http module and as such should provide the original IncomingMessage\n * object. This allows the buildRequestObject method to be framework agnostic\n * in it's translation to the json-api Request object.\n *\n * @param {Object} options A set of configuration options.\n *\n * @param {boolean} options.tunnel Whether to turn on PATCH tunneling. See:\n *    http://jsonapi.org/recommendations/#patchless-clients\n *\n * @param {boolean} options.handleContentNegotiation If the JSON API library\n *    can't produce a representation for the response that the client can\n *    `Accept`, should it return 406 or should it hand the request back to\n *    to the framwork so that subsequent handlers can attempt to find an\n *    alternate representation? By default, it does the former.\n */\n\nvar BaseStrategy = (function () {\n  function BaseStrategy(apiController, docsController, options) {\n    _classCallCheck(this, BaseStrategy);\n\n    var defaultOptions = {\n      tunnel: false,\n      handleContentNegotiation: true\n    };\n\n    this.api = apiController;\n    this.docs = docsController;\n    this.config = _Object$assign({}, defaultOptions, options); // apply options\n  }\n\n  /**\n   * Builds a Request object from an IncomingMessage object. It is not\n   * possible to infer the protocol or the url params from the IncomingMessage\n   * object alone so they must be passed as arguments. Optionally a query object\n   * can be passed, otherwise the query parameters will be inferred from the\n   * IncomingMessage url property and parsed using the qs node module.\n   *\n   * @param {http.IncomingMessage} req original request object from core node module http\n   * @param {string} protocol\n   * @param {string} host\n   * @param {Object} params object containing url parameters\n   * @param {Object} [query] object containing query parameters\n   */\n\n  _createClass(BaseStrategy, [{\n    key: \"buildRequestObject\",\n    value: function buildRequestObject(req, protocol, host, params, query) {\n      var config = this.config;\n\n      return _q2[\"default\"].Promise(function (resolve, reject) {\n        var it = new _typesHTTPRequest2[\"default\"]();\n\n        // Handle route & query params\n        if (query) {\n          it.queryParams = query;\n        } else if (req.url.indexOf(\"?\") !== -1) {\n          it.queryParams = _qs2[\"default\"].parse(req.url.split(\"?\")[1]);\n        }\n\n        it.allowLabel = !!(params.idOrLabel && !params.id);\n        it.idOrIds = params.id || params.idOrLabel;\n        it.type = params.type;\n        it.aboutRelationship = !!params.relationship;\n        it.relationship = params.related || params.relationship;\n\n        // Handle HTTP/Conneg.\n        protocol = protocol || (req.connection.encrypted ? \"https\" : \"http\");\n        host = host || req.headers.host;\n\n        it.uri = protocol + \"://\" + host + req.url;\n        it.method = req.method.toLowerCase();\n        it.accepts = req.headers.accept;\n\n        // Support Verb tunneling, but only for PATCH and only if user turns it on.\n        // Turning on any tunneling automatically could be a security issue.\n        var requestedMethod = (req.headers[\"x-http-method-override\"] || \"\").toLowerCase();\n        if (config.tunnel && it.method === \"post\" && requestedMethod === \"patch\") {\n          it.method = \"patch\";\n        } else if (requestedMethod) {\n          reject(new _typesAPIError2[\"default\"](400, undefined, \"Cannot tunnel to the method \\\"\" + requestedMethod.toUpperCase() + \"\\\".\"));\n        }\n\n        if (hasBody(req)) {\n          if (!isReadableStream(req)) {\n            return reject(new _typesAPIError2[\"default\"](500, undefined, \"Request body could not be parsed. Make sure other no other middleware has already parsed the request body.\"));\n          }\n\n          it.contentType = req.headers[\"content-type\"];\n          var typeParsed = _contentType2[\"default\"].parse(req);\n\n          var bodyParserOptions = {};\n          bodyParserOptions.encoding = typeParsed.parameters.charset || \"utf8\";\n          bodyParserOptions.limit = \"1mb\";\n          if (req.headers[\"content-length\"] && !isNaN(req.headers[\"content-length\"])) {\n            bodyParserOptions.length = req.headers[\"content-length\"];\n          }\n\n          // The req has not yet been read, so let's read it\n          (0, _rawBody2[\"default\"])(req, bodyParserOptions, function (err, string) {\n            if (err) {\n              reject(err);\n            }\n\n            // Even though we passed the hasBody check, the body could still be\n            // empty, so we check the length. (We can't check this before doing\n            // getRawBody because, while Content-Length: 0 signals an empty body,\n            // there's no similar in-advance clue for detecting empty bodies when\n            // Transfer-Encoding: chunked is being used.)\n            else if (string.length === 0) {\n                it.hasBody = false;\n                it.body = \"\";\n                resolve(it);\n              } else {\n                try {\n                  it.hasBody = true;\n                  it.body = JSON.parse(string);\n                  resolve(it);\n                } catch (error) {\n                  reject(new _typesAPIError2[\"default\"](400, undefined, \"Request contains invalid JSON.\"));\n                }\n              }\n          });\n        } else {\n          it.hasBody = false;\n          it.body = undefined;\n          resolve(it);\n        }\n      });\n    }\n  }]);\n\n  return BaseStrategy;\n})();\n\nexports[\"default\"] = BaseStrategy;\n\nfunction hasBody(req) {\n  return req.headers[\"transfer-encoding\"] !== undefined || !isNaN(req.headers[\"content-length\"]);\n}\n\nfunction isReadableStream(req) {\n  return typeof req._readableState === \"object\" && req._readableState.endEmitted === false;\n}\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/types/HTTP/Request.js":"\"use strict\";\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utilTypeHandling = require(\"../../util/type-handling\");\n\nvar Request = function Request() {\n  _classCallCheck(this, Request);\n\n  // Whether the request has a (non-empty) body,\n  // in which case we'll need to validate the Content-Type.\n  this.hasBody = null;\n\n  // Whether the request is supposed to have a body.\n  // If it needsBody but doesn't have one, it's invalid.\n  this.needsBody = null;\n\n  // The json of the body. Have to use Object.defineProperty to default\n  // it to undefined while still allowing us to change it post seal().\n  Object.defineProperty(this, \"body\", { writable: true, enumerable: true });\n\n  // The HTTP method for the request.\n  this.method = null;\n\n  // The URI (or IRI) being requested.\n  this.uri = null;\n\n  // The request's Content-Type.\n  this.contentType = null;\n\n  // The request's Accept header.\n  this.accepts = null;\n\n  // The JSON-API extensions used to formulate the request,\n  // read from the Content-Type header's `ext` param.\n  this.ext = [];\n\n  // Whether we can process the id in the url as a label for this request.\n  this.allowLabel = false;\n\n  // The id provided in the request's url, optionally after treating that\n  // id as a label and mapping it to one or more entity ids. Note also:\n  // the request could be something like /people/1/author, so the id(s)\n  // stored here may not be the id(s) of the requested resource.\n  this.idOrIds = null;\n\n  // The type provided in the request's url. As above, requests like\n  // /people/1/author imply that the type stored here may not be that\n  // of the returned resourses.\n  this.type = null;\n\n  // The relationship name provided in the request's url. This is the\n  // \"author\" part in the example /people/1/author request noted above.\n  this.relationship = null;\n\n  // Whether the target of the request is a relationship (object), as opposed\n  // to a resource object or collection. This effects how incoming data is\n  // parsed. Note: the body of the request will be Linkage rather than\n  // Relationships, in the same way that POSTs targeting a collection\n  // include a single resource.\n  this.aboutRelationship = false;\n\n  // Any primary data included in the request's body.\n  // Necessary for creating and updating our resources.\n  this.primary = null;\n\n  // Query parameters that might influence the request.\n  this.queryParams = {};\n};\n\nexports[\"default\"] = (0, _utilTypeHandling.ValueObject)(Request);\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/build/src/http-strategies/Koa.js":"\"use strict\";\n\nvar _get = require(\"babel-runtime/helpers/get\")[\"default\"];\n\nvar _inherits = require(\"babel-runtime/helpers/inherits\")[\"default\"];\n\nvar _createClass = require(\"babel-runtime/helpers/create-class\")[\"default\"];\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _regeneratorRuntime = require(\"babel-runtime/regenerator\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _vary = require(\"vary\");\n\nvar _vary2 = _interopRequireDefault(_vary);\n\nvar _controllersAPI = require(\"../controllers/API\");\n\nvar _controllersAPI2 = _interopRequireDefault(_controllersAPI);\n\nvar _Base2 = require(\"./Base\");\n\nvar _Base3 = _interopRequireDefault(_Base2);\n\n/**\n * This controller receives requests directly from Koa and sends responses\n * directly through it, but it converts incoming requests to, and generates\n * responses, from Request and Response objects that are defined by this\n * framework in a way that's not particular to Koa. This controller thereby\n * acts as a translation-layer between Koa and the rest of this json-api\n * framework.\n *\n * @param {Object} options A set of configuration options.\n *\n * @param {boolean} options.tunnel Whether to turn on PATCH tunneling. See:\n *    http://jsonapi.org/recommendations/#patchless-clients\n *\n * @param {boolean} options.handleContentNegotiation If the JSON API library\n *    can't produce a representation for the response that the client can\n *    `Accept`, should it return 406 or should it hand the request back to\n *    Koa (i.e. yield next) so that subsequent handlers can attempt to\n *    find an alternate representation? By default, it does the former. But you\n *    can set this option to false to have this code just pass on to Koa.\n */\n\nvar KoaStrategy = (function (_Base) {\n  _inherits(KoaStrategy, _Base);\n\n  function KoaStrategy(apiController, docsController, options) {\n    _classCallCheck(this, KoaStrategy);\n\n    _get(Object.getPrototypeOf(KoaStrategy.prototype), \"constructor\", this).call(this, apiController, docsController, options);\n  }\n\n  // For requests like GET /:type, GET /:type/:id/:relationship,\n  // POST /:type PATCH /:type/:id, PATCH /:type, DELETE /:type/:idOrLabel,\n  // DELETE /:type, GET /:type/:id/links/:relationship,\n  // PATCH /:type/:id/links/:relationship, POST /:type/:id/links/:relationship,\n  // and DELETE /:type/:id/links/:relationship.\n\n  _createClass(KoaStrategy, [{\n    key: \"apiRequest\",\n    value: function apiRequest() {\n      var strategy = this;\n      return _regeneratorRuntime.mark(function callee$2$0(next) {\n        var ctx, reqObj, resObj, delegate406Handling;\n        return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n          while (1) switch (context$3$0.prev = context$3$0.next) {\n            case 0:\n              ctx = this;\n              context$3$0.prev = 1;\n              context$3$0.next = 4;\n              return strategy.buildRequestObject(ctx.req, ctx.protocol, ctx.host, ctx.params);\n\n            case 4:\n              reqObj = context$3$0.sent;\n              context$3$0.next = 7;\n              return strategy.api.handle(reqObj, ctx);\n\n            case 7:\n              resObj = context$3$0.sent;\n              delegate406Handling = strategy.sendResources(resObj, ctx);\n\n              if (!delegate406Handling) {\n                context$3$0.next = 12;\n                break;\n              }\n\n              context$3$0.next = 12;\n              return next;\n\n            case 12:\n              context$3$0.next = 17;\n              break;\n\n            case 14:\n              context$3$0.prev = 14;\n              context$3$0.t0 = context$3$0[\"catch\"](1);\n\n              strategy.sendError(context$3$0.t0, this);\n\n            case 17:\n            case \"end\":\n              return context$3$0.stop();\n          }\n        }, callee$2$0, this, [[1, 14]]);\n      });\n    }\n\n    // For requests for the documentation.\n  }, {\n    key: \"docsRequest\",\n    value: function docsRequest() {\n      var strategy = this;\n      return _regeneratorRuntime.mark(function callee$2$0(next) {\n        var ctx, reqObj, resObj, delegate406Handling;\n        return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {\n          while (1) switch (context$3$0.prev = context$3$0.next) {\n            case 0:\n              ctx = this;\n              context$3$0.prev = 1;\n              context$3$0.next = 4;\n              return strategy.buildRequestObject(ctx.req, ctx.protocol, ctx.host, ctx.params);\n\n            case 4:\n              reqObj = context$3$0.sent;\n              context$3$0.next = 7;\n              return strategy.docs.handle(reqObj, ctx);\n\n            case 7:\n              resObj = context$3$0.sent;\n              delegate406Handling = strategy.sendResources(resObj, ctx);\n\n              if (!delegate406Handling) {\n                context$3$0.next = 12;\n                break;\n              }\n\n              context$3$0.next = 12;\n              return next;\n\n            case 12:\n              context$3$0.next = 17;\n              break;\n\n            case 14:\n              context$3$0.prev = 14;\n              context$3$0.t0 = context$3$0[\"catch\"](1);\n\n              strategy.sendError(context$3$0.t0, this);\n\n            case 17:\n            case \"end\":\n              return context$3$0.stop();\n          }\n        }, callee$2$0, this, [[1, 14]]);\n      });\n    }\n  }, {\n    key: \"sendResources\",\n    value: function sendResources(responseObject, ctx) {\n      if (responseObject.headers.vary) {\n        (0, _vary2[\"default\"])(ctx.res, responseObject.headers.vary);\n      }\n\n      if (!responseObject.contentType) {\n        if (this.config.handleContentNegotiation) {\n          ctx.status = 406;\n        } else {\n          return true;\n        }\n      } else {\n        ctx.set(\"Content-Type\", responseObject.contentType);\n        ctx.status = responseObject.status || 200;\n\n        if (responseObject.headers.location) {\n          ctx.set(\"Location\", responseObject.headers.location);\n        }\n\n        if (responseObject.body !== null) {\n          ctx.body = new Buffer(responseObject.body);\n        }\n      }\n    }\n\n    /**\n     * A user of this library may wish to send an error response for an exception\n     * that originated outside of the JSON API Pipeline and that's outside the\n     * main spec's scope (e.g. an authentication error). So, the controller\n     * exposes this method which allows them to do that.\n     *\n     * @param {Error|APIError|Error[]|APIError[]} errors Error or array of errors\n     * @param {Object} ctx Koa's context object\n     */\n  }, {\n    key: \"sendError\",\n    value: function sendError(errors, ctx) {\n      var _this = this;\n\n      _controllersAPI2[\"default\"].responseFromExternalError(errors, ctx.headers.accept).then(function (responseObject) {\n        return _this.sendResources(responseObject, ctx);\n      })[\"catch\"](function (err) {\n        // if we hit an error generating our error...\n        ctx[\"throw\"](err.message, err.status);\n      });\n    }\n  }]);\n\n  return KoaStrategy;\n})(_Base3[\"default\"]);\n\nexports[\"default\"] = KoaStrategy;\nmodule.exports = exports[\"default\"];","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/ResourceTypeRegistry.js":"import Immutable from \"immutable\";\nimport {pseudoTopSort} from \"./util/misc\";\nimport {Maybe} from \"./util/type-handling\";\n\n/**\n * A private array of properties that will be used by the class below to\n * automatically generate simple getters for each property, all following the\n * same format. Those getters will take the name of the resource type whose\n * property is being retrieved.\n */\nconst autoGetterProps = [\"dbAdapter\", \"beforeSave\", \"beforeRender\", \"behaviors\",\n  \"labelMappers\", \"defaultIncludes\", \"info\", \"parentType\"];\n\n/**\n * Global defaults for all resource descriptions, to be merged into the\n * defaults provided to the ResourceTypeRegistry, which are in turn merged\n * into the values provided in each resource type description.\n */\nconst globalResourceDefaults = Immutable.fromJS({\n  behaviors: {\n    dasherizeOutput: { enabled: true }\n  }\n});\n\nconst typesKey = Symbol();\n\n/**\n * To fulfill a JSON API request, you often need to know about all the resources\n * types in the system--not just the type that is the primary target of the\n * request. For example, if the request is for a User (or Users), you might need\n * to include related Projects, so the code handling the users request needs\n * access to the Project resource's beforeSave and beforeRender methods; its\n * url templates; etc. So we handle this by introducing a ResourceTypeRegistry\n * that the Controller can have access to. Each resource type is registered by\n * its JSON API type and has a number of properties defining it.\n */\nexport default class ResourceTypeRegistry {\n  constructor(typeDescriptions = {}, descriptionDefaults = {}) {\n    this[typesKey] = {};\n    descriptionDefaults = globalResourceDefaults.mergeDeep(descriptionDefaults);\n\n    // Sort the types so we can register them in an order that respects their\n    // parentType. First, we pre-process the typeDescriptions to create edges\n    // pointing to each node's children (rather than the links we have by\n    // default, which point to the parent). Then we do an abridged topological\n    // sort that works in this case. Below, nodes is a list of type names.\n    // Roots are nodes with no parents. Edges is a map, with each key being the\n    // name of a starting node A, and the value being a set of node names for\n    // which there is an edge from A to that node.\n    const nodes = [], roots = [], edges = {};\n\n    for(const typeName in typeDescriptions) {\n      const nodeParentType = typeDescriptions[typeName].parentType;\n      nodes.push(typeName);\n\n      if(nodeParentType) {\n        edges[nodeParentType] = edges[nodeParentType] || {};\n        edges[nodeParentType][typeName] = true;\n      }\n      else {\n        roots.push(typeName);\n      }\n    }\n\n    const typeRegistrationOrder = pseudoTopSort(nodes, edges, roots);\n\n    // register the types, in order\n    typeRegistrationOrder.forEach((typeName) => {\n      const parentType = typeDescriptions[typeName].parentType;\n\n      // defaultIncludes need to be made into an object if they came as an array.\n      // TODO: Remove support for array format before v3. It's inconsistent.\n      const thisDescriptionRaw = Immutable.fromJS(typeDescriptions[typeName]);\n      const thisDescriptionMerged = descriptionDefaults.mergeDeep(thisDescriptionRaw);\n\n      this[typesKey][typeName] = (parentType) ?\n        // If we have a parentType, we merge in all the parent's fields,\n        // BUT we then overwrite labelMappers with just the ones directly\n        // from this description. We don't inherit labelMappers because a\n        // labelMapper is a kind of filter, and the results of a filter\n        // on the parent type may not be instances of the subtype.\n        this[typesKey][parentType].mergeDeep(thisDescriptionRaw)\n          .set(\"labelMappers\", thisDescriptionRaw.get(\"labelMappers\")) :\n\n        // If we don't have a parentType, just register\n        // the description merged with the universal defaults\n        thisDescriptionMerged;\n    });\n  }\n\n  type(typeName) {\n    return Maybe(this[typesKey][typeName]).bind(it => it.toJS()).unwrap();\n  }\n\n  hasType(typeName) {\n    return typeName in this[typesKey];\n  }\n\n  typeNames() {\n    return Object.keys(this[typesKey]);\n  }\n\n  urlTemplates(type) {\n    if(type) {\n      return Maybe(this[typesKey][type])\n        .bind(it => it.get(\"urlTemplates\"))\n        .bind(it => it.toJS())\n        .unwrap();\n    }\n\n    return Object.keys(this[typesKey]).reduce((prev, typeName) => {\n      prev[typeName] = this.urlTemplates(typeName);\n      return prev;\n    }, {});\n  }\n}\n\nautoGetterProps.forEach((propName) => {\n  ResourceTypeRegistry.prototype[propName] = makeGetter(propName);\n});\n\nfunction makeGetter(attrName) {\n  return function(type) {\n    return Maybe(this[typesKey][type])\n      .bind(it => it.get(attrName))\n      .bind(it => it instanceof Immutable.Map || it instanceof Immutable.List ? it.toJS() : it)\n      .unwrap();\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/templates/ConditionalSection.js":"$(function() {\n  //just the conditional section widget from https://github.com/ethanresnick/ConditionalSection\n  var ConditionalSections = function(){function a(a){var b,c,d=this;this.container=a;b={that:this};c=function(a){return d.handleEvent(a)};this.toggle=a.find(\".\"+this.constants.classToggle);this.section=a.find(\".\"+this.constants.classSection).eq(0);this.isShown=0<this.toggle.find(\":checked\").length;0===this.toggle.find(\"input, a\").length&&this.toggle.contents().wrap('<a href=\"\" onclick=\"return false;\" />');this.toggle.find(\"input\").length?this.toggle.change(b,c):this.toggle.click(b,c)}a.prototype.handleEvent=function(a){return this.update()};a.prototype.update=function(){this.isShown=!this.isShown;return this.render()};a.prototype.render=function(){this.container.removeClass(this.constants.classHidden+\" \"+this.constants.classShown).addClass(this.isShown?this.constants.classShown:this.constants.classHidden);return null};a.prototype.constants={classContainer:\"conditional-section\",classHidden:\"condition-not-met\",classShown:\"condition-met\",classSection:\"contents\",classToggle:\"toggle\"};return a}();\n\n  $('.conditional-section').each(function() {\n    x = new ConditionalSections($(this));\n    x.render();\n  });\n})","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/controllers/API.js":"import co from \"co\";\n\nimport Response from \"../types/HTTP/Response\";\nimport Document from \"../types/Document\";\nimport Collection from \"../types/Collection\";\nimport APIError from \"../types/APIError\";\n\nimport * as requestValidators from \"../steps/http/validate-request\";\nimport negotiateContentType from \"../steps/http/content-negotiation/negotiate-content-type\";\nimport validateContentType from \"../steps/http/content-negotiation/validate-content-type\";\n\n\nimport labelToIds from \"../steps/pre-query/label-to-ids\";\nimport parseRequestPrimary from \"../steps/pre-query/parse-request-primary\";\nimport validateRequestDocument from \"../steps/pre-query/validate-document\";\nimport validateRequestResources from \"../steps/pre-query/validate-resources\";\nimport applyTransform from \"../steps/apply-transform\";\n\nimport doGET from \"../steps/do-query/do-get\";\nimport doPOST from \"../steps/do-query/do-post\";\nimport doPATCH from \"../steps/do-query/do-patch\";\nimport doDELETE from \"../steps/do-query/do-delete\";\n\nlet supportedExt = [];\n\n// We have to globally patch Promise for co to work, even though global patches\n// are suboptimal. See https://github.com/ethanresnick/json-api/issues/47\n// We use eval so that the runtime transformer doesn't replace our check for an\n// existing Promise with an invocation of the polyfill.\n/*eslint-disable no-eval */\nGLOBAL.Promise = eval(\"typeof Promise !== 'undefined' ? Promise : undefined\") ||\n  require(\"babel-runtime/core-js/promise\").default;\n/*eslint-enable no-eval */\n\nclass APIController {\n  constructor(registry) {\n    this.registry = registry;\n  }\n\n  /**\n   * @param {Request} request The Request this controller will use to generate\n   *    the Response.\n   * @param {Object} frameworkReq This should be the request object generated by\n   *    the framework that you're using. But, really, it can be absolutely\n   *    anything, as this controller won't use it for anything except passing it\n   *    to user-provided functions that it calls (like transforms and id mappers).\n   * @param {Object} frameworkRes Theoretically, the response objcet generated\n   *     by your http framework but, like with frameworkReq, it can be anything.\n   */\n  handle(request, frameworkReq, frameworkRes) {\n    let response = new Response();\n    let registry = this.registry;\n\n    // Kick off the chain for generating the response.\n    return co(function*() {\n      try {\n        // check that a valid method is in use\n        yield requestValidators.checkMethod(request);\n\n        // throw if the body is supposed to be present but isn't (or vice-versa).\n        yield requestValidators.checkBodyExistence(request);\n\n        // Try to negotiate the content type (may fail, and we may need to\n        // deviate from the negotiated value if we have to return an error\n        // body, rather than our expected response).\n        response.contentType = yield negotiateContentType(\n          request.accepts, [\"application/vnd.api+json\"]\n        );\n\n        // No matter what, though, we're varying on Accept. See:\n        // https://github.com/ethanresnick/json-api/issues/22\n        response.headers.vary = \"Accept\";\n\n        // If the type requested in the endpoint hasn't been registered, we 404.\n        if(!registry.hasType(request.type)) {\n          throw new APIError(404, undefined, `${request.type} is not a valid type.`);\n        }\n\n        // If the request has a body, validate it and parse its resources.\n        if(request.hasBody) {\n          yield validateContentType(request, supportedExt);\n          yield validateRequestDocument(request.body);\n\n          let parsedPrimary = yield parseRequestPrimary(\n            request.body.data, request.aboutRelationship\n          );\n\n          // validate the request's resources.\n          if(!request.aboutRelationship) {\n            yield validateRequestResources(request.type, parsedPrimary, registry);\n          }\n\n          request.primary = yield applyTransform(\n            parsedPrimary, \"beforeSave\", registry, frameworkReq, frameworkRes\n          );\n        }\n\n        // Map label to idOrIds, if applicable.\n        if(request.idOrIds && request.allowLabel) {\n          let mappedLabel = yield labelToIds(\n            request.type, request.idOrIds, registry, frameworkReq\n          );\n\n          // set the idOrIds on the request context\n          request.idOrIds = mappedLabel;\n\n          // if our new ids are null/undefined or an empty array, we can set\n          // the primary resources too! (Note: one could argue that we should\n          // 404 rather than return null when the label matches no ids.)\n          let mappedIsEmptyArray = Array.isArray(mappedLabel) && !mappedLabel.length;\n\n          if(mappedLabel === null || mappedLabel === undefined || mappedIsEmptyArray) {\n            response.primary = (mappedLabel) ? new Collection() : null;\n          }\n        }\n\n        // Actually fulfill the request!\n        // If we've already populated the primary resources, which is possible\n        // because the label may have mapped to no id(s), we don't need to query.\n        if(typeof response.primary === \"undefined\") {\n          switch(request.method) {\n            case \"get\":\n              yield doGET(request, response, registry);\n              break;\n\n            case \"post\":\n              yield doPOST(request, response, registry);\n              break;\n\n            case \"patch\":\n              yield doPATCH(request, response, registry);\n              break;\n\n            case \"delete\":\n              yield doDELETE(request, response, registry);\n          }\n        }\n      }\n\n      // Add errors to the response converting them, if necessary, to\n      // APIError instances first. Might be needed if, e.g., the error was\n      // unexpected (and so uncaught and not transformed) in one of prior steps\n      // or the user couldn't throw an APIError for compatibility with other code.\n      catch (errors) {\n        let errorsArr = Array.isArray(errors) ? errors : [errors];\n        let apiErrors = errorsArr.map(APIError.fromError);\n\n        // Leave the error response's content type as JSON if we negotiated\n        // for that, but otherwise force it to JSON API, since that's the only\n        // other error format we know how to generate.\n        if(response.contentType !== \"application/json\") {\n          response.contentType = \"application/vnd.api+json\";\n        }\n\n        // Set the other key fields on the response\n        response.errors = response.errors.concat(apiErrors);\n        //console.log(\"API CONTROLLER ERRORS\", errorsArr[0], errorsArr[0].stack);\n      }\n\n      // If we have errors, which could have come from prior steps not just\n      // throwing, return here and don't bother with transforms.\n      if(response.errors.length) {\n        response.status = pickStatus(response.errors.map((v) => Number(v.status)));\n        response.body = new Document(response.errors).get(true);\n        return response;\n      }\n\n      // apply transforms pre-send\n      response.primary = yield applyTransform(\n        response.primary, \"beforeRender\", registry, frameworkReq, frameworkRes\n      );\n\n      response.included = yield applyTransform(\n        response.included, \"beforeRender\", registry, frameworkReq, frameworkRes\n      );\n\n      if(response.status !== 204) {\n        response.body = new Document(\n          response.primary, response.included,\n          undefined, registry.urlTemplates(), request.uri\n        ).get(true);\n      }\n\n      return response;\n    });\n  }\n\n  /**\n   * Builds a response from errors. Allows errors that occur outside of the\n   * library to be handled and returned in JSON API-compiant fashion.\n   *\n   * @param {Error|APIError|Error[]|APIError[]} errors Error or array of errors\n   * @param {string} requestAccepts Request's Accepts header\n   */\n  static responseFromExternalError(errors, requestAccepts) {\n    let response = new Response();\n\n    // Convert to array\n    response.errors = Array.isArray(errors) ? errors : [errors];\n\n    // Convert Errors to APIErrors\n    response.errors = response.errors.map(APIError.fromError.bind(APIError));\n\n    response.status = pickStatus(response.errors.map((v) => Number(v.status)));\n    response.body = new Document(response.errors).get(true);\n\n    return negotiateContentType(requestAccepts, [\"application/vnd.api+json\"])\n      .then((contentType) => {\n        response.contentType = (contentType.toLowerCase() === \"application/json\")\n          ? contentType : \"application/vnd.api+json\";\n        return response;\n      }, () => {\n        // if we couldn't find any acceptable content-type,\n        // just ignore the accept header, as http allows.\n        response.contentType = \"application/vnd.api+json\";\n        return response;\n      }\n    );\n  }\n}\n\nAPIController.supportedExt = supportedExt;\n\nexport default APIController;\n\n/**\n * Returns the status code that best represents a set of error statuses.\n */\nfunction pickStatus(errStatuses) {\n  return errStatuses[0];\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/controllers/Documentation.js":"import Q from \"q\";\nimport _ from \"lodash\";\nimport path from \"path\";\nimport jade from \"jade\";\nimport Negotiator from \"negotiator\";\nimport dasherize from \"dasherize\";\nimport mapValues from \"lodash/object/mapValues\";\n\nimport Response from \"../types/HTTP/Response\";\nimport Document from \"../types/Document\";\nimport Collection from \"../types/Collection\";\nimport Resource from \"../types/Resource\";\n\nexport default class DocumentationController {\n  constructor(registry, apiInfo, templatePath, dasherizeJSONKeys = true) {\n    this.registry = registry;\n\n    const defaultTempPath = \"../../../templates/documentation.jade\";\n    this.template = templatePath || path.resolve(__dirname, defaultTempPath);\n\n    this.dasherizeJSONKeys = dasherizeJSONKeys;\n\n    // compute template data on construction\n    // (it never changes, so this makes more sense than doing it per request)\n    let data = Object.assign({}, apiInfo);\n    data.resourcesMap = {};\n\n    // Store in the resourcesMap the info object about each type,\n    // as returned by @getTypeInfo.\n    this.registry.typeNames().forEach((typeName) => {\n      data.resourcesMap[typeName] = this.getTypeInfo(typeName);\n    });\n\n    this.templateData = data;\n  }\n\n  handle(request, frameworkReq, frameworkRes) {\n    let response = new Response();\n    let negotiator = new Negotiator({headers: {accept: request.accepts}});\n    let contentType = negotiator.mediaType([\"text/html\", \"application/vnd.api+json\"]);\n\n    // set content type as negotiated & vary on accept.\n    response.contentType = contentType;\n    response.headers.vary = \"Accept\";\n\n    // process templateData (just the type infos for now) for this particular request.\n    let templateData = _.cloneDeep(this.templateData, cloneCustomizer);\n    templateData.resourcesMap = mapValues(templateData.resourcesMap, (typeInfo, typeName) => {\n      return this.transformTypeInfo(typeName, typeInfo, request, response, frameworkReq, frameworkRes);\n    });\n\n    if(contentType.toLowerCase() === \"text/html\") {\n      response.body = jade.renderFile(this.template, templateData);\n    }\n\n    else {\n      // Create a collection of \"jsonapi-descriptions\" from the templateData\n      let descriptionResources = new Collection();\n\n      // Add a description resource for each resource type to the collection.\n      for(let type in templateData.resourcesMap) {\n        descriptionResources.add(\n          new Resource(\"jsonapi-descriptions\", type, templateData.resourcesMap[type])\n        );\n      }\n\n      response.body = (new Document(descriptionResources)).get(true);\n    }\n\n    return Q(response);\n  }\n\n  // Clients can extend this if, say, the adapter can't infer\n  // as much info about the models' structure as they would like.\n  getTypeInfo(type) {\n    const adapter   = this.registry.dbAdapter(type);\n    const modelName = adapter.constructor.getModelName(type);\n    const model     = adapter.getModel(modelName);\n\n    // Combine the docs in the Resource description with the standardized schema\n    // from the adapter in order to build the final schema for the template.\n    const info = this.registry.info(type);\n    const schema = adapter.constructor.getStandardizedSchema(model);\n    const ucFirst = (v) => v.charAt(0).toUpperCase() + v.slice(1);\n\n    schema.forEach((field) => {\n      // look up user defined field info on info.fields.\n      let pathInfo = (info && info.fields && info.fields[field.name]) || {};\n\n      // Keys that have a meaning in the default template.\n      let overrideableKeys = [\"friendlyName\",  \"kind\", \"description\"];\n\n      for(let key in pathInfo) {\n        // allow the user to override auto-generated friendlyName and the\n        // auto-generated type info, which is undefined for virtuals. Also,\n        // allow them to set the description, which is always user-provided.\n        // And, finally, copy in any other info properties that don't\n        // conflict with ones defined by this library.\n        if (overrideableKeys.indexOf(key) > -1 || !(key in field)) {\n          field[key] = pathInfo[key];\n        }\n\n        // If the current info key does conflict (i.e. `key in field`), but\n        // the user-provided value is an object, try to merge in the object's\n        // properties. If the key conflicts and doesn't hold an object into\n        // which we can merge, we just give up (i.e. we don't try anything\n        // else after the below).\n        else if(typeof field[key] === \"object\" && !Array.isArray(field[key])) {\n          Object.assign(field[key], pathInfo[key]);\n        }\n      }\n    });\n    // Other info\n    let result = {\n      name: {\n        \"model\": modelName,\n        \"singular\": adapter.constructor.toFriendlyName(modelName),\n        \"plural\": type.split(\"-\").map(ucFirst).join(\" \")\n      },\n      fields: schema,\n      parentType: this.registry.parentType(type),\n      childTypes: adapter.constructor.getChildTypes(model)\n    };\n\n    let defaultIncludes = this.registry.defaultIncludes(type);\n    if(defaultIncludes) result.defaultIncludes = defaultIncludes;\n\n    if(info && info.example) result.example = info.example;\n    if(info && info.description) result.description = info.description;\n\n    return result;\n  }\n\n  /**\n   * By extending this function, users have an opportunity to transform\n   * the documentation info for each type based on the particulars of the\n   * current request. This is useful, among other things, for showing\n   * users documentation only for models they have access to, and it lays\n   * the groundwork for true HATEOS intro pages in the future.\n   */\n  transformTypeInfo(typeName, info, request, response, frameworkReq, frameworkRes) {\n    if(this.dasherizeJSONKeys && response.contentType === \"application/vnd.api+json\") {\n      return dasherize(info);\n    }\n    return info;\n  }\n}\n\n/**\n * A function to pass to _.cloneDeep to customize the result.\n * Basically, it \"pseudo-constructs\" new instances of any objects\n * that were instantiated with custom classes/constructor functions\n * before. It does this by making a plain object version of the\n * instance (i.e. it's local state as captured by it's enumerable\n * own properties) and setting the `.constructor` and [[Prototype]]\n * on that plain object. This isn't identical to constructing a new\n * instance of course, which could have other side-effects (and also\n * effects super() binding on real ES6 classes), but it's better than\n * just using a plain object.\n */\nfunction cloneCustomizer(value) {\n  if(isCustomObject(value)) {\n    let state = _.cloneDeep(value);\n    Object.setPrototypeOf(state, Object.getPrototypeOf(value));\n    Object.defineProperty(state, \"constructor\", {\n      \"writable\": true,\n      \"enumerable\": false,\n      \"value\": value.constructor\n    });\n\n    // handle the possibiliy that a key in state was itself a non-plain object\n    for(let key in state) {\n      if(isCustomObject(value[key])) {\n        state[key] = _.cloneDeep(value[key], cloneCustomizer);\n      }\n    }\n\n    return state;\n  }\n\n  return undefined;\n}\n\nfunction isCustomObject(v) {\n  return v && typeof v === \"object\" && v.constructor !== Object && !Array.isArray(v);\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/http-strategies/Base.js":"import Q from \"q\";\nimport qs from \"qs\";\nimport contentType from \"content-type\";\nimport getRawBody from \"raw-body\";\nimport APIError from \"../types/APIError\";\nimport Request from \"../types/HTTP/Request\";\n\n/**\n * This controller is the base for http strategy classes. It's built around\n * the premise that most if not all http frameworks are built on top of the\n * core http module and as such should provide the original IncomingMessage\n * object. This allows the buildRequestObject method to be framework agnostic\n * in it's translation to the json-api Request object.\n *\n * @param {Object} options A set of configuration options.\n *\n * @param {boolean} options.tunnel Whether to turn on PATCH tunneling. See:\n *    http://jsonapi.org/recommendations/#patchless-clients\n *\n * @param {boolean} options.handleContentNegotiation If the JSON API library\n *    can't produce a representation for the response that the client can\n *    `Accept`, should it return 406 or should it hand the request back to\n *    to the framwork so that subsequent handlers can attempt to find an\n *    alternate representation? By default, it does the former.\n */\nexport default class BaseStrategy {\n  constructor(apiController, docsController, options) {\n    const defaultOptions = {\n      tunnel: false,\n      handleContentNegotiation: true\n    };\n\n    this.api = apiController;\n    this.docs = docsController;\n    this.config = Object.assign({}, defaultOptions, options); // apply options\n  }\n\n  /**\n   * Builds a Request object from an IncomingMessage object. It is not\n   * possible to infer the protocol or the url params from the IncomingMessage\n   * object alone so they must be passed as arguments. Optionally a query object\n   * can be passed, otherwise the query parameters will be inferred from the\n   * IncomingMessage url property and parsed using the qs node module.\n   *\n   * @param {http.IncomingMessage} req original request object from core node module http\n   * @param {string} protocol\n   * @param {string} host\n   * @param {Object} params object containing url parameters\n   * @param {Object} [query] object containing query parameters\n   */\n  buildRequestObject(req, protocol, host, params, query){\n    const config = this.config;\n\n    return Q.Promise(function(resolve, reject) {\n      let it = new Request();\n\n      // Handle route & query params\n      if(query) {\n        it.queryParams = query;\n      }\n      else if(req.url.indexOf(\"?\") !== -1) {\n        it.queryParams = qs.parse(req.url.split(\"?\")[1]);\n      }\n\n      it.allowLabel        = !!(params.idOrLabel && !params.id);\n      it.idOrIds           = params.id || params.idOrLabel;\n      it.type              = params.type;\n      it.aboutRelationship = !!params.relationship;\n      it.relationship      = params.related || params.relationship;\n\n      // Handle HTTP/Conneg.\n      protocol  = protocol || (req.connection.encrypted ? \"https\" : \"http\");\n      host      = host || req.headers.host;\n\n      it.uri     = protocol + \"://\" + host + req.url;\n      it.method  = req.method.toLowerCase();\n      it.accepts = req.headers.accept;\n\n      // Support Verb tunneling, but only for PATCH and only if user turns it on.\n      // Turning on any tunneling automatically could be a security issue.\n      let requestedMethod = (req.headers[\"x-http-method-override\"] || \"\").toLowerCase();\n      if(config.tunnel && it.method === \"post\" && requestedMethod === \"patch\") {\n        it.method = \"patch\";\n      }\n      else if(requestedMethod) {\n        reject(\n          new APIError(400, undefined, `Cannot tunnel to the method \"${requestedMethod.toUpperCase()}\".`)\n        );\n      }\n\n      if(hasBody(req)) {\n        if(!isReadableStream(req)) {\n          return reject(\n            new APIError(500, undefined, \"Request body could not be parsed. Make sure other no other middleware has already parsed the request body.\")\n          );\n        }\n\n        it.contentType  = req.headers[\"content-type\"];\n        const typeParsed = contentType.parse(req);\n\n        let bodyParserOptions = {};\n        bodyParserOptions.encoding = typeParsed.parameters.charset || \"utf8\";\n        bodyParserOptions.limit = \"1mb\";\n        if(req.headers[\"content-length\"] && !isNaN(req.headers[\"content-length\"])) {\n          bodyParserOptions.length = req.headers[\"content-length\"];\n        }\n\n        // The req has not yet been read, so let's read it\n        getRawBody(req, bodyParserOptions, function(err, string) {\n          if(err) {\n            reject(err);\n          }\n\n          // Even though we passed the hasBody check, the body could still be\n          // empty, so we check the length. (We can't check this before doing\n          // getRawBody because, while Content-Length: 0 signals an empty body,\n          // there's no similar in-advance clue for detecting empty bodies when\n          // Transfer-Encoding: chunked is being used.)\n          else if(string.length === 0) {\n            it.hasBody = false;\n            it.body = \"\";\n            resolve(it);\n          }\n\n          else {\n            try {\n              it.hasBody = true;\n              it.body = JSON.parse(string);\n              resolve(it);\n            }\n            catch (error) {\n              reject(\n                new APIError(400, undefined, \"Request contains invalid JSON.\")\n              );\n            }\n          }\n        });\n      }\n\n      else {\n        it.hasBody = false;\n        it.body = undefined;\n        resolve(it);\n      }\n    });\n  }\n}\n\nfunction hasBody(req) {\n  return req.headers[\"transfer-encoding\"] !== undefined || !isNaN(req.headers[\"content-length\"]);\n}\n\nfunction isReadableStream(req) {\n  return typeof req._readableState === \"object\" && req._readableState.endEmitted === false;\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/http-strategies/Express.js":"import vary from \"vary\";\nimport API from \"../controllers/API\";\nimport Base from \"./Base\";\n\n/**\n * This controller receives requests directly from express and sends responses\n * directly through it, but it converts incoming requests to, and generates\n * responses, from Request and Response objects that are defined by this\n * framework in a way that's not particular to express. This controller thereby\n * acts as a translation-layer between express and the rest of this json-api\n * framework.\n *\n * @param {Object} options A set of configuration options.\n *\n * @param {boolean} options.tunnel Whether to turn on PATCH tunneling. See:\n *    http://jsonapi.org/recommendations/#patchless-clients\n *\n * @param {boolean} options.handleContentNegotiation If the JSON API library\n *    can't produce a representation for the response that the client can\n *    `Accept`, should it return 406 or should it hand the request back to\n *    Express (i.e. call next()) so that subsequent handlers can attempt to\n *    find an alternate representation? By default, it does the former. But you\n *    can set this option to false to have this code just pass on to Express.\n */\nexport default class ExpressStrategy extends Base {\n  constructor(apiController, docsController, options) {\n    super(apiController, docsController, options);\n  }\n\n  // For requests like GET /:type, GET /:type/:id/:relationship,\n  // POST /:type PATCH /:type/:id, PATCH /:type, DELETE /:type/:idOrLabel,\n  // DELETE /:type, GET /:type/:id/links/:relationship,\n  // PATCH /:type/:id/links/:relationship, POST /:type/:id/links/:relationship,\n  // and DELETE /:type/:id/links/:relationship.\n  apiRequest(req, res, next) {\n    this.buildRequestObject(req, req.protocol, req.get(\"Host\"), req.params, req.query).then((requestObject) => {\n      return this.api.handle(requestObject, req, res).then((responseObject) => {\n        this.sendResources(responseObject, res, next);\n      });\n    }).catch((err) => {\n      this.sendError(err, req, res);\n    });\n  }\n\n  // For requests for the documentation.\n  docsRequest(req, res, next) {\n    this.buildRequestObject(req, req.protocol, req.get(\"Host\"), req.params, req.query).then((requestObject) => {\n      return this.docs.handle(requestObject, req, res).then((responseObject) => {\n        this.sendResources(responseObject, res, next);\n      });\n    }).catch((err) => {\n      this.sendError(err, req, res);\n    });\n  }\n\n  sendResources(responseObject, res, next) {\n    if(responseObject.headers.vary) {\n      vary(res, responseObject.headers.vary);\n    }\n\n    if(!responseObject.contentType) {\n      if(this.config.handleContentNegotiation) {\n        res.status(406).send();\n      }\n      else {\n        next();\n      }\n    }\n\n    else {\n      res.set(\"Content-Type\", responseObject.contentType);\n      res.status(responseObject.status || 200);\n\n      if(responseObject.headers.location) {\n        res.set(\"Location\", responseObject.headers.location);\n      }\n\n      if(responseObject.body !== null) {\n        res.send(new Buffer(responseObject.body)).end();\n      }\n      else {\n        res.end();\n      }\n    }\n  }\n\n  /**\n   * A user of this library may wish to send an error response for an exception\n   * that originated outside of the JSON API Pipeline and that's outside the\n   * main spec's scope (e.g. an authentication error). So, the controller\n   * exposes this method which allows them to do that.\n   *\n   * @param {Error|APIError|Error[]|APIError[]} errors Error or array of errors\n   * @param {Object} req Express's request object\n   * @param {Object} res Express's response object\n   */\n  sendError(errors, req, res) {\n    API.responseFromExternalError(errors, req.headers.accept).then(\n      (responseObject) => this.sendResources(responseObject, res, () => {})\n    ).catch((err) => {\n      // if we hit an error generating our error...\n      res.status(err.status).send(err.message);\n    });\n  }\n\n  /**\n   * @TODO Uses this ExpressStrategy to create an express app with\n   * preconfigured routes that can be mounted as a subapp.\n  toApp(typesToExcludedMethods) {\n  }\n  */\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/http-strategies/Koa.js":"import vary from \"vary\";\nimport API from \"../controllers/API\";\nimport Base from \"./Base\";\n\n/**\n * This controller receives requests directly from Koa and sends responses\n * directly through it, but it converts incoming requests to, and generates\n * responses, from Request and Response objects that are defined by this\n * framework in a way that's not particular to Koa. This controller thereby\n * acts as a translation-layer between Koa and the rest of this json-api\n * framework.\n *\n * @param {Object} options A set of configuration options.\n *\n * @param {boolean} options.tunnel Whether to turn on PATCH tunneling. See:\n *    http://jsonapi.org/recommendations/#patchless-clients\n *\n * @param {boolean} options.handleContentNegotiation If the JSON API library\n *    can't produce a representation for the response that the client can\n *    `Accept`, should it return 406 or should it hand the request back to\n *    Koa (i.e. yield next) so that subsequent handlers can attempt to\n *    find an alternate representation? By default, it does the former. But you\n *    can set this option to false to have this code just pass on to Koa.\n */\nexport default class KoaStrategy extends Base {\n  constructor(apiController, docsController, options) {\n    super(apiController, docsController, options);\n  }\n\n  // For requests like GET /:type, GET /:type/:id/:relationship,\n  // POST /:type PATCH /:type/:id, PATCH /:type, DELETE /:type/:idOrLabel,\n  // DELETE /:type, GET /:type/:id/links/:relationship,\n  // PATCH /:type/:id/links/:relationship, POST /:type/:id/links/:relationship,\n  // and DELETE /:type/:id/links/:relationship.\n  apiRequest() {\n    const strategy = this;\n    return function *(next){\n      const ctx = this;\n      try {\n        const reqObj = yield strategy.buildRequestObject(ctx.req, ctx.protocol, ctx.host, ctx.params);\n        const resObj = yield strategy.api.handle(reqObj, ctx);\n        const delegate406Handling = strategy.sendResources(resObj, ctx);\n        if(delegate406Handling){\n          yield next;\n        }\n      }\n      catch (err) {\n        strategy.sendError(err, this);\n      }\n    };\n  }\n\n  // For requests for the documentation.\n  docsRequest() {\n    const strategy = this;\n    return function *(next){\n      const ctx = this;\n      try {\n        const reqObj = yield strategy.buildRequestObject(ctx.req, ctx.protocol, ctx.host, ctx.params);\n        const resObj = yield strategy.docs.handle(reqObj, ctx);\n        const delegate406Handling = strategy.sendResources(resObj, ctx);\n        if(delegate406Handling){\n          yield next;\n        }\n      }\n      catch (err) {\n        strategy.sendError(err, this);\n      }\n    };\n  }\n\n  sendResources(responseObject, ctx) {\n    if(responseObject.headers.vary) {\n      vary(ctx.res, responseObject.headers.vary);\n    }\n\n    if(!responseObject.contentType) {\n      if(this.config.handleContentNegotiation) {\n        ctx.status = 406;\n      }\n      else {\n        return true;\n      }\n    }\n    else {\n      ctx.set(\"Content-Type\", responseObject.contentType);\n      ctx.status = responseObject.status || 200;\n\n      if(responseObject.headers.location) {\n        ctx.set(\"Location\", responseObject.headers.location);\n      }\n\n      if(responseObject.body !== null) {\n        ctx.body = new Buffer(responseObject.body);\n      }\n    }\n  }\n\n  /**\n   * A user of this library may wish to send an error response for an exception\n   * that originated outside of the JSON API Pipeline and that's outside the\n   * main spec's scope (e.g. an authentication error). So, the controller\n   * exposes this method which allows them to do that.\n   *\n   * @param {Error|APIError|Error[]|APIError[]} errors Error or array of errors\n   * @param {Object} ctx Koa's context object\n   */\n  sendError(errors, ctx) {\n    API.responseFromExternalError(errors, ctx.headers.accept).then(\n      (responseObject) => this.sendResources(responseObject, ctx)\n    ).catch((err) => {\n      // if we hit an error generating our error...\n      ctx.throw(err.message, err.status);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/steps/apply-transform.js":"import Resource from \"../types/Resource\";\nimport Collection from \"../types/Collection\";\nimport { Promise } from \"q\";\n\n/**\n * @param toTransform Could be a single resource, a collection, a link object, or null.\n */\nexport default function(toTransform, mode, registry, frameworkReq, frameworkRes) {\n  if(toTransform instanceof Resource) {\n    return transform(toTransform, frameworkReq, frameworkRes, mode, registry);\n  }\n\n  else if (toTransform instanceof Collection) {\n    // below, allow the user to return undefined to remove a vlaue.\n    return Promise.all(toTransform.resources.map((it) =>\n      transform(it, frameworkReq, frameworkRes, mode, registry)\n    )).then((transformed) =>\n      new Collection(transformed.filter((it) => it !== undefined))\n    );\n  }\n\n  // We only transform resources or collections.\n  else {\n    return Promise.resolve(toTransform);\n  }\n}\n\nfunction transform(resource, req, res, transformMode, registry) {\n  let transformFn = registry[transformMode](resource.type);\n\n  // SuperFn is a function that the first transformer can invoke.\n  // It'll return the resource passed in (i.e. do nothing) if there\n  // is no parentType or the parentType doesn't define an appropriate\n  // transformer. Otherwise, it'll return the result of calling\n  // the parentType's transformer with the provided arguments.\n  let superFn = (resource, req, res) => { // eslint-disable-line no-shadow\n    let parentType = registry.parentType(resource.type);\n\n    if(!parentType || !registry[transformMode](parentType)) {\n      return resource;\n    }\n    else {\n      return registry[transformMode](parentType)(resource, req, res, superFn);\n    }\n  };\n\n  if (!transformFn) {\n    return Promise.resolve(resource);\n  }\n\n  // Allow user to return a Promise or a value\n  let transformed = transformFn(resource, req, res, superFn);\n  return Promise.resolve(transformed);\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/types/APIError.js":"let nonEnumerable = {writable: true, enumerable: false};\n\nexport default class APIError extends Error {\n  /*eslint-disable no-unused-vars */\n  constructor(status, code, title, detail, links, paths) {\n    super();\n\n    // Hack around lack of proxy support and default non-enumerability\n    // of class accessor properties, while still giving us validation.\n    Object.defineProperty(this, \"_status\", nonEnumerable);\n    Object.defineProperty(this, \"_code\", nonEnumerable);\n    Object.defineProperty(this, \"status\", {\n      enumerable: true,\n      get: () => this._status,\n      set: (value) => {\n        if(typeof value !== \"undefined\" && value !== null) {\n          this._status = String(value).toString();\n        }\n        else {\n          this._status = value;\n        }\n      }\n    });\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      get: () => this._code,\n      set: (value) => {\n        if(typeof value !== \"undefined\" && value !== null) {\n          this._code = String(value).toString();\n        }\n        else {\n          this._code = value;\n        }\n      }\n    });\n\n    [this.status, this.code, this.title, this.detail, this.links, this.paths] = Array.from(arguments);\n  }\n  /*eslint-enable */\n\n  /**\n   * Creates a JSON-API Compliant Error Object from a JS Error object\n   *\n   */\n  static fromError(err) {\n    const fallbackTitle = \"An unknown error occurred while trying to process this request.\";\n    const ErrorConstructor = this || APIError; // in case this isn't bound.\n\n    if(err instanceof APIError) {\n      return err;\n    }\n\n    // If the error is marked as ready for JSON API display, it's secure\n    // to read values off it and show them to the user. (Note: most of\n    // the args below will probably be null/undefined, but that's fine.)\n    else if(err.isJSONAPIDisplayReady) {\n      return new ErrorConstructor(\n        err.status || err.statusCode || 500,\n        err.code,\n        err.title || fallbackTitle,\n        err.details || (err.message ? err.message : undefined),\n        err.links,\n        err.paths\n      );\n    }\n\n    // Otherwise, we just show a generic error message.\n    else {\n      return new ErrorConstructor(500, undefined, fallbackTitle);\n    }\n\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/types/Collection.js":"export default class Collection {\n  constructor(resources = []) {\n    this.resources = resources;\n  }\n\n  get ids() {\n    return this.resources.map(it => it.id);\n  }\n\n  get types() {\n    return this.resources.map(it => it.type);\n  }\n\n  add(resource) {\n    this.resources.push(resource);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/types/Document.js":"import Linkage from \"./Linkage\";\nimport Resource from \"./Resource\";\nimport Collection from \"./Collection\";\nimport {objectIsEmpty, mapResources, mapObject} from \"../util/type-handling\";\nimport {arrayUnique} from \"../util/arrays\";\nimport templating from \"url-template\";\n\nexport default class Document {\n  constructor(primaryOrErrors, included, meta, urlTemplates, reqURI) {\n    [this.primaryOrErrors, this.included, this.reqURI] = [primaryOrErrors, included, reqURI];\n\n    // validate meta\n    if(meta !== undefined) {\n      if(typeof meta === \"object\" && !Array.isArray(meta)) {\n        this.meta = meta;\n      }\n      else {\n        throw new Error(\"Meta information must be an object\");\n      }\n    }\n\n    // parse all the templates once on construction.\n    this.urlTemplates = mapObject(urlTemplates || {}, (templatesForType) => {\n      return mapObject(templatesForType, templating.parse.bind(templating));\n    });\n\n    this.reqURI = reqURI;\n  }\n\n  get(stringify) {\n    let doc = {};\n\n    if(this.meta) doc.meta = this.meta;\n\n    // TODO: top-level related link.\n    if(this.reqURI) {\n      doc.links = {\"self\": this.reqURI};\n    }\n\n    if(this.primaryOrErrors instanceof Collection || this.primaryOrErrors instanceof Resource) {\n      doc.data = mapResources(this.primaryOrErrors, (resource) => {\n        return resourceToJSON(resource, this.urlTemplates);\n      });\n    }\n\n    else if(this.primaryOrErrors instanceof Linkage) {\n      doc.data = linkageToJSON(this.primaryOrErrors);\n    }\n\n    else if(this.primaryOrErrors === null) {\n      doc.data = this.primaryOrErrors;\n    }\n\n    // it's either resource, a collection, linkage, null, or errors...\n    else {\n      doc.errors = this.primaryOrErrors.map(errorToJSON);\n    }\n\n    if(this.included && this.included instanceof Collection) {\n      doc.included = arrayUnique(this.included.resources).map((resource) => {\n        return resourceToJSON(resource, this.urlTemplates);\n      });\n    }\n\n    return stringify ? JSON.stringify(doc) : doc;\n  }\n}\n\nfunction linkageToJSON(linkage) {\n  return linkage && linkage.value;\n}\n\nfunction relationshipToJSON(relationship, urlTemplates, templateData) {\n  let result = {};\n\n  if(relationship.linkage) {\n    result.data = linkageToJSON(relationship.linkage);\n  }\n\n  // Add urls that we can.\n  if(urlTemplates[templateData.ownerType]) {\n    const relatedUrlTemplate = relationship.relatedURITemplate ?\n      templating.parse(relationship.relatedURITemplate) :\n      urlTemplates[templateData.ownerType].related;\n\n    const selfUrlTemplate = relationship.selfURITemplate ?\n      templating.parse(relationship.selfURITemplate) :\n      urlTemplates[templateData.ownerType].relationship;\n\n    if(relatedUrlTemplate || selfUrlTemplate) {\n      result.links = {};\n    }\n\n    if(relatedUrlTemplate) {\n      result.links.related = relatedUrlTemplate.expand(templateData);\n    }\n\n    if(selfUrlTemplate) {\n      result.links.self = selfUrlTemplate.expand(templateData);\n    }\n  }\n\n  return result;\n}\n\nfunction resourceToJSON(resource, urlTemplates) {\n  let json = {};\n  json.id = resource.id;\n  json.type = resource.type;\n  json.attributes = resource.attrs;\n\n  if(resource.meta && !objectIsEmpty(resource.meta)) {\n    json.meta = resource.meta;\n  }\n\n  // use type, id, meta and attrs for template data, even though building\n  // links from attr values is usually stupid (but there are cases for it).\n  let templateData = Object.assign({}, json);\n  let selfTemplate = urlTemplates[resource.type] && urlTemplates[resource.type].self;\n\n  if(!objectIsEmpty(resource.links) || selfTemplate) {\n    json.links = {};\n    if(selfTemplate) {\n      json.links.self = selfTemplate.expand(templateData);\n    }\n  }\n\n  if(!objectIsEmpty(resource.relationships)) {\n    json.relationships = {};\n\n    for(let path in resource.relationships) {\n      let linkTemplateData = {\"ownerType\": json.type, \"ownerId\": json.id, \"path\": path};\n      json.relationships[path] = relationshipToJSON(resource.relationships[path], urlTemplates, linkTemplateData);\n    }\n  }\n\n\n  return json;\n}\n\nfunction errorToJSON(error) {\n  let res = {};\n  for(let key in error) {\n    if(error.hasOwnProperty(key)) {\n      res[key] = error[key];\n    }\n  }\n  return res;\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/types/Linkage.js":"export default class Linkage {\n  /**\n   * Linkage can be either: null, an empty array,\n   * an object of the form {type, id}, or [{type, id}].\n   */\n  constructor(value) {\n    this.set(value);\n  }\n\n  set(value) {\n    if(value === null) {\n      this.value = value;\n    }\n\n    else if(!Array.isArray(value)) {\n      if(isValidLinkageObject(value)) {\n        this.value = value;\n      }\n      else {\n        throw new InvalidLinkageError(value);\n      }\n    }\n    else {\n      this.value = [];\n      value.forEach(this.add.bind(this));\n    }\n  }\n\n  add(newValue) {\n    if(Array.isArray(this.value)) {\n      if(isValidLinkageObject(newValue)) {\n        this.value.push(newValue);\n      }\n      else {\n        throw new InvalidLinkageError(newValue);\n      }\n    }\n    else {\n      throw new Error(\n        \"You can only add values to Linkage objects for to-many relationships.\"\n      );\n    }\n  }\n\n  empty() {\n    this.value = Array.isArray(this.value) ? [] : null;\n  }\n}\n\nfunction InvalidLinkageError(value) {\n  return new Error(\"Invalid linkage value: \" + JSON.stringify(value));\n}\n\nfunction isValidLinkageObject(it) {\n  return typeof it.type === \"string\" && typeof it.id === \"string\";\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/types/Relationship.js":"export default class Relationship {\n  constructor(linkage, relatedURITemplate, selfURITemplate) {\n    Object.assign(this, {linkage, relatedURITemplate, selfURITemplate});\n  }\n\n  empty() {\n    this.linkage.empty();\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/types/Resource.js":"import {deleteNested, isPlainObject} from \"../util/misc\";\n\nexport default class Resource {\n  constructor(type, id, attrs = {}, relationships = {}, meta = {}) {\n    [this.type, this.id, this.attrs, this.relationships, this.meta] =\n      [type, id, attrs, relationships, meta];\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(id) {\n    // allow empty id for the case of a new resource POST.\n    this._id = (id) ? String(id) : undefined;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    if(!type) {\n      throw new Error(\"type is required\");\n    }\n\n    this._type = String(type);\n  }\n\n  equals(otherResource) {\n    return this.id === otherResource.id && this.type === otherResource.type;\n  }\n\n  get attrs() {\n    return this._attrs;\n  }\n\n  set attrs(attrs) {\n    validateFieldGroup(attrs, this._relationships, true);\n    this._attrs = attrs;\n  }\n\n  get relationships() {\n    return this._relationships;\n  }\n\n  set relationships(relationships) {\n    validateFieldGroup(relationships, this._attrs);\n    this._relationships = relationships;\n  }\n\n  removeAttr(attrPath) {\n    if(this._attrs) {\n      deleteNested(attrPath, this._attrs);\n    }\n  }\n\n  removeRelationship(relationshipPath) {\n    if(this._relationships) {\n      deleteNested(relationshipPath, this._relationships);\n    }\n  }\n}\n\n/**\n * Checks that a group of fields (i.e. the attributes or the relationships\n * objects) are provided as objects and that they don't contain `type` and\n * `id` members. Also checks that attributes and relationships don't contain\n * the same keys as one another, and it checks that complex attributes don't\n * contain \"relationships\" or \"links\" members.\n *\n * @param {Object} group The an object of fields (attributes or relationships)\n *    that the user is trying to add to the Resource.\n * @param {Object} otherFields The other fields that will still exist on the\n *    Resource. The new fields are checked against these other fields for\n *    naming conflicts.\n * @param {Boolean} isAttributes Whether the `group` points to the attributes\n *    of the resource. Triggers complex attribute validation.\n * @return {undefined}\n * @throws {Error} If the field group is invalid given the other fields.\n */\nfunction validateFieldGroup(group, otherFields, isAttributes) {\n  if(!isPlainObject(group)) {\n    throw new Error(\"Attributes and relationships must be provided as an object.\");\n  }\n\n  if(typeof group.id !== \"undefined\" || typeof group.type !== \"undefined\") {\n    throw new Error(\"`type` and `id` cannot be used as attribute or relationship names.\");\n  }\n\n  for(let field in group) {\n    if(isAttributes) {\n      validateComplexAttribute(group[field]);\n    }\n\n    if(otherFields !== undefined && typeof otherFields[field] !== \"undefined\") {\n      throw new Error(\"A resource can't have an attribute and a relationship with the same name.\");\n    }\n  }\n}\n\nfunction validateComplexAttribute(attrOrAttrPart) {\n  if(isPlainObject(attrOrAttrPart)) {\n    if(typeof attrOrAttrPart.relationships !== \"undefined\" || typeof attrOrAttrPart.links !== \"undefined\") {\n      throw new Error('Complex attributes may not have \"relationships\" or \"links\" keys.');\n    }\n    for(let key in attrOrAttrPart) {\n      validateComplexAttribute(attrOrAttrPart[key]);\n    }\n  }\n  else if(Array.isArray(attrOrAttrPart)) {\n    attrOrAttrPart.forEach(validateComplexAttribute);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/util/arrays.js":"export function arrayUnique(array) {\n  return array.filter((a, b, c) => c.indexOf(a, b + 1) < 0);\n}\n\nexport function arrayValuesMatch(array1, array2) {\n  return array1.length === array2.length &&\n    array1.sort().join() === array2.sort().join();\n}\n\nexport function arrayContains(arr, value) {\n  if(!Number.isNaN(value)) {\n    return arr.indexOf(value) !== -1;\n  }\n  else {\n    return arr.some(Number.isNaN) === true;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/util/misc.js":"/**\n * Takes an arbitrary path string e.g. \"user.contact.phone\" and locates the\n * corresponding property on an object `obj` and deletes it (ie. does\n * `delete obj.user.contact.phone`). It doesn't use eval, which makes it safer.\n */\nexport function deleteNested(path, object) {\n  try {\n    let pathParts = path.split(\".\");\n    let lastPartIndex = pathParts.length - 1;\n    let lastPart = pathParts[lastPartIndex];\n    let containingParts = pathParts.slice(0, lastPartIndex);\n    let container = containingParts.reduce(((obj, part) => obj[part]), object);\n\n    if(container.hasOwnProperty(lastPart)) {\n      delete container[lastPart];\n      return true;\n    }\n    else {\n      throw new Error(\"The last property in the path didn't exist on the object.\");\n    }\n  }\n\n  catch(error) {\n    return false;\n  }\n}\n\n/**\n * Returns whether one array's items are a subset of those in the other.\n * Both array's elements are assumed to be unique.\n */\nexport function isSubsetOf(setArr, potentialSubsetArr) {\n  const set = new Set(setArr);\n\n  return potentialSubsetArr.every((it) => set.has(it) === true);\n}\n\nexport function isPlainObject(obj) {\n  return typeof obj === \"object\" && !(Array.isArray(obj) || obj === null);\n}\n\n/**\n * Perform a pseudo-topological sort on the provided graph. Pseudo because it\n * assumes that each node only has 0 or 1 incoming edges, as is the case with\n * graphs for parent-child inheritance hierarchies (w/o multiple inheritance).\n * Uses https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n *\n * @param  {string[]} nodes A list of nodes, where each node is just a string.\n *\n * @param {string[]} roots The subset of nodes that have no incoming edges.\n *\n * @param  {object} edges The edges, expressed such that each key is a starting\n * node A, and the value is a set of nodes (as an object literal like\n * {nodeName: true}) for each of which there is an edge from A to that node.\n *\n * @return {string[]} The nodes, sorted.\n */\nexport function pseudoTopSort(nodes, edges, roots) {\n  // Do some defensive copying, in case the caller didn't.\n  roots = roots.slice();\n  nodes = nodes.slice();\n  edges = Object.assign({}, edges);\n  for(const key in edges) { edges[key] = Object.assign({}, edges[key]); }\n\n  // \"L = Empty list that will contain the sorted elements\"\n  const sortResult = [];\n\n  // \"while S is non-empty do\"\n  while(roots.length) {\n    // \"remove a node n from S\"\n    // We shift() instead of pop() to we preserve more of the\n    // original order, in case it was significant to the user.\n    const thisRoot = roots.shift();\n    const thisRootChildren = edges[thisRoot] || {};\n\n    // \"add n to tail of L\"\n    sortResult.push(thisRoot);\n\n    // \"for each node m with an edge e from n to m do\"\n    for(const child in thisRootChildren) {\n      // \"remove edge e from the graph\"\n      delete thisRootChildren[child];\n\n      // SKIP: \"if m has no other incoming edges...\"\n      // we don't need this check because we assumed max 1 incoming edge.\n      // But: \"then insert m into S\".\n      roots.push(child);\n    }\n  }\n\n  return sortResult;\n}\n","/home/travis/build/npmtest/node-npmtest-json-api/node_modules/json-api/src/util/type-handling.js":"import Collection from \"../types/Collection\";\n\n/**\n * Takes in a constructor function that takes no arguments and returns a new one\n * that takes one argument representing initial values. These initial values\n * will be applied to the properties that exist on the object returned by the\n * input constructor function immediately post-creation. Then the object will be\n * sealed so that no properties can be added or deleted--a nice sanity check.\n */\nexport function ValueObject(ConstructorFn) {\n  return function(initialValues) {\n    let obj = new ConstructorFn();\n    let hasOwnProp = Object.prototype.hasOwnProperty;\n\n    // Use initial values where possible.\n    if(initialValues) {\n      for(let key in obj) {\n        if(hasOwnProp.call(obj, key) && hasOwnProp.call(initialValues, key)) {\n          obj[key] = initialValues[key];\n        }\n      }\n    }\n\n    // Object.seal prevents any other properties from being added to the object.\n    // Every property an object needs should be set by the original constructor.\n    return Object.seal(obj);\n  };\n}\n\nexport function objectIsEmpty(obj) {\n  let hasOwnProperty = Object.prototype.hasOwnProperty;\n  for (let key in obj) {\n    if (hasOwnProperty.call(obj, key)) return false;\n  }\n  return true;\n}\n\nexport function mapObject(obj, mapFn) {\n  let mappedObj = Object.assign({}, obj);\n\n  for(let key in mappedObj) {\n    mappedObj[key] = mapFn(obj[key]);\n  }\n\n  return mappedObj;\n}\n\n/**\n * If `resourceOrCollection` is a collection, it applies `mapFn` to each of\n * its resources; otherwise, if `resourceOrCollection` is a single resource,\n * it applies `mapFn` just to that resource. This abstracts a common pattern.\n */\nexport function mapResources(resourceOrCollection, mapFn) {\n  if(resourceOrCollection instanceof Collection) {\n    return resourceOrCollection.resources.map(mapFn);\n  }\n  else {\n    return mapFn(resourceOrCollection);\n  }\n}\n\nexport function forEachResources(resourceOrCollection, eachFn) {\n  /*eslint-disable no-unused-expressions */\n  if(resourceOrCollection instanceof Collection) {\n    resourceOrCollection.resources.forEach(eachFn);\n  }\n  else {\n    return eachFn(resourceOrCollection);\n  }\n  /*eslint-enable */\n}\n\nexport function groupResourcesByType(resourceOrCollection) {\n  const resourcesByType = {};\n  if(resourceOrCollection instanceof Collection) {\n    resourceOrCollection.resources.forEach((it) => {\n      resourcesByType[it.type] = resourcesByType[it.type] || [];\n      resourcesByType[it.type].push(it);\n    });\n  }\n  else {\n    resourcesByType[resourceOrCollection.type] = [resourceOrCollection];\n  }\n  return resourcesByType;\n}\n\nexport function forEachArrayOrVal(arrayOrVal, eachFn) {\n  /*eslint-disable no-unused-expressions */\n  Array.isArray(arrayOrVal) ? arrayOrVal.forEach(eachFn) : eachFn(arrayOrVal);\n  /*eslint-enable */\n}\n\n\n/**\n * The Maybe monad, with a totally-not-monadic unwrap() so we can\n * get out the raw value w/o needing to pass the monad everywhere.\n *\n * We also match js's convention from Promise of not requiring\n * the user's bind() to always return the monad. If a raw value\n * x is returned, it's converted to Maybe(x).\n */\nexport const Nothing = {\n  unwrap() {\n    return undefined;\n  },\n\n  bind() {\n    return this;\n  }\n};\n\nexport class Just {\n  constructor(x) {\n    this.val = x;\n  }\n\n  unwrap() {\n    return this.val;\n  }\n\n  bind(transform) {\n    const transformed = transform(this.val);\n    if(transformed instanceof Just || transformed === Nothing) {\n      return transformed;\n    }\n    else {\n      return Maybe(transformed);\n    }\n  }\n}\n\nexport function Maybe(x) {\n  // Sometimes, null is a valid value, so Nothing only covers undefined.\n  if(x !== undefined) {\n    return new Just(x);\n  }\n  else {\n    return Nothing;\n  }\n}\n"}